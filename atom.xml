<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://star2dust.github.io</id>
    <title>star2dust</title>
    <updated>2021-11-29T01:17:17.006Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://star2dust.github.io"/>
    <link rel="self" href="https://star2dust.github.io/atom.xml"/>
    <subtitle>每天进步一点点</subtitle>
    <logo>https://star2dust.github.io/images/avatar.png</logo>
    <icon>https://star2dust.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, star2dust</rights>
    <entry>
        <title type="html"><![CDATA[【力扣刷题】双指针和滑动窗口]]></title>
        <id>https://star2dust.github.io/post/leetcode-sliding-window/</id>
        <link href="https://star2dust.github.io/post/leetcode-sliding-window/">
        </link>
        <updated>2021-11-28T04:01:53.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88">双指针</a>
<ul>
<li><a href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">27. 移除元素</a></li>
<li><a href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9">26. 删除有序数组中的重复项</a></li>
<li><a href="#80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii">80. 删除有序数组中的重复项 II</a></li>
<li><a href="#844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">844. 比较含退格的字符串</a></li>
<li><a href="#977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9">977.有序数组的平方</a></li>
</ul>
</li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a>
<ul>
<li><a href="#209%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">209.长度最小的子数组</a></li>
<li><a href="#904%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE">904.水果成篮</a></li>
<li><a href="#76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2">76.最小覆盖子串</a></li>
</ul>
</li>
</ul>
</p>
<p>本文总结了双指针和滑动窗口的常见题型。</p>
<h1 id="双指针">双指针</h1>
<p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</strong>，达到减少时间复杂度的作用。</p>
<p><strong>双指针法在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<h2 id="27-移除元素">27. 移除元素</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a>：给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
</code></pre>
</blockquote>
<p>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</p>
<p>数组的基础知识可以看这里<a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">程序员算法面试中，必须掌握的数组理论知识</a>。</p>
<p>本题思路是，设置快慢指针，先同时移动，直到指向第一个要删除的位置，快指针多移动一位。</p>
<p>之后每次同时移动，做两件事：</p>
<ul>
<li>快指针位置的值复制到慢指针位置</li>
<li>快指针指向要删除位置时，快指针多移动一位</li>
</ul>
<p>最后慢指针位置即为数组长度。</p>
<pre><code class="language-cpp">// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="26-删除有序数组中的重复项">26. 删除有序数组中的重复项</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a>：给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
</code></pre>
</blockquote>
<p>注意到数组<strong>有序</strong>，因此重复元素必定相邻，那就简单多了。</p>
<pre><code class="language-cpp">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        // 判空
        if (nums.size()==0) return 0;
        // 如果非空，第一个数字不变，从第二个开始
        int l = 1;
        for (int r = 1; r &lt; nums.size(); r++){
            if (nums[r] != nums[l-1]){
                nums[l++] = nums[r];
            }
        }
        return l;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，只需要使用常数的额外空间。</p>
<h2 id="80-删除有序数组中的重复项-ii">80. 删除有序数组中的重复项 II</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a>：给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
</code></pre>
</blockquote>
<p>本题要求最多出现<code>2</code>次，直接的思路是加个计数项，如果重复个数超过2个就加一次拷贝动作。</p>
<pre><code class="language-cpp">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.size()==0) return 0;
        int l = 1, r = 1, cnt = 0;//计数
        while (r &lt; nums.size()){
            if (nums[r] != nums[r-1]){
                //加一次拷贝动作
                if (cnt &gt; 0) {
                    nums[l++] = nums[r-1];
                    cnt = 0;
                }
                nums[l++] = nums[r];
            }else{
                cnt++;
            }
            r++;
        }
        // 结尾还要加一次拷贝动作
        if (cnt &gt; 0) {
            nums[l++] = nums[r-1];
            cnt = 0;
        }
        return l;
    }
};
</code></pre>
<p>扩展一下，如果要求最多重复<code>k</code>次呢？</p>
<pre><code class="language-cpp">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums, int k) {
        if (nums.size() &lt;= k) return nums.size();
        int l = k, r = k;
        while (r &lt; nums.size()){
            if (nums[r] != nums[l-k]){
                nums[l++] = nums[r];
            }
            r++;
        }
        return l;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中 n 是数组的长度。我们最多遍历该数组一次。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，我们只需要常数的空间存储若干变量。</p>
<h2 id="844-比较含退格的字符串">844. 比较含退格的字符串</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/backspace-string-compare/">844. 比较含退格的字符串</a>：给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，请你判断二者是否相等。<code>#</code> 代表退格字符。</p>
<p>如果相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>**注意：**如果对空文本输入退格字符，文本继续为空。</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：s = &quot;ab#c&quot;, t = &quot;ad#c&quot;
输出：true
解释：S 和 T 都会变成 “ac”。
</code></pre>
</blockquote>
<p>本题中一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</p>
<p>具体地，我们定义<code>cnts</code>、<code>cntt</code>表示当前待删除的字符的数量。每次我们遍历到一个字符：</p>
<p>若该字符为退格符，则我们需要多删除一个普通字符，我们让<code>cnts</code>、<code>cntt</code>加 1；</p>
<p>若该字符为普通字符：</p>
<p>若<code>cnts</code>、<code>cntt</code>为 0，则说明当前字符不需要删去；</p>
<p>若<code>cnts</code>、<code>cntt</code>不为 0，则说明当前字符需要删去，我们让<code>cnts</code>、<code>cntt</code>减 1。</p>
<p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。</p>
<pre><code class="language-cpp">class Solution {
public:
    bool backspaceCompare(string s, string t) {
	int ps = s.length() - 1, pt = t.length() - 1;
	int cnts = 0, cntt = 0;
	while (ps &gt;= 0 || pt &gt;= 0){
        // s中查找下一个需要比较的字符
		while (ps &gt;= 0){
			if (s[ps] == '#'){
				cnts++; ps--;
			}
			else if (cnts &gt; 0){
				cnts--; ps--;
			}
			else{
				break;
			}
		}
        // t中查找下一个需要比较的字符
		while (pt &gt;= 0){
			if (t[pt] == '#'){
				cntt++; pt--;
			}
			else if (cntt &gt; 0){
				cntt--; pt--;
			}
			else{
				break;
			}
		}
        // ps、pt同时为0才可能相等
		if (ps &gt;= 0 &amp;&amp; pt &gt;= 0){
			if (s[ps] != t[pt]){
				return false;
			}
		}// 不同时为0直接结束比较
		else{
			if (ps &gt;= 0 || pt &gt;= 0){
				return false;
			}
		}
		ps--; pt--;
	}
	return true;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N+M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，其中 N 和 M 分别为字符串 S 和 T 的长度。我们需要遍历两字符串各一次。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。对于每个字符串，我们只需要定义一个指针和一个计数器即可。</p>
<h2 id="977有序数组的平方">977.有序数组的平方</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a>：给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
</code></pre>
</blockquote>
<p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>
<p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p>
<p>定义一个新数组result，和nums数组一样的大小，让k指向result数组终止位置。</p>
<p>如果<code>nums[i] * nums[i] &lt; nums[j] * nums[j]</code>  那么<code>result[k--] = nums[j] * nums[j];</code>  。</p>
<p>如果<code>nums[i] * nums[i] &gt;= nums[j] * nums[j]</code> 那么<code>result[k--] = nums[i] * nums[i];</code> 。</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int l = 0, r = n - 1, k = n - 1;
        vector&lt;int&gt; res(n);
        while (k&gt;=0){
            if (nums[l] * nums[l] &gt; nums[r] * nums[r]){
                res[k--] = nums[l] * nums[l];
                l++;
            }
            else{
                res[k--] = nums[r] * nums[r];
                r--;
            }
        }
        return res;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​，其中 n 是数组 nums 的长度，相对于暴力排序的解法<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n + n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​​还是提升不少的。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。除了存储答案的数组以外，我们只需要维护常量空间。</p>
<h1 id="滑动窗口">滑动窗口</h1>
<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>
<p>滑动窗口也可以理解为双指针法的一种，只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p>
<p>实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？（题目要求）</li>
<li>如何移动窗口的起始位置？（判断条件）</li>
<li>如何移动窗口的结束位置？（遍历指针）</li>
</ul>
<h2 id="209长度最小的子数组">209.长度最小的子数组</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209.长度最小的子数组</a>：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
</code></pre>
</blockquote>
<p>本题中的窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值<strong>大于s</strong>了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的<strong>结束位置就是遍历数组的指针</strong>，窗口的起始位置设置为数组的起始位置就可以了。</p>
<p>由于结束位置直接跟着循环跑，不用自己移动，所以滑动窗口也可以看作单指针。</p>
<p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p>
<p>C++代码如下：</p>
<pre><code class="language-CPP">class Solution {
public:
    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j &lt; nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum &gt;= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result &lt; subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p><strong>为什么时间复杂度是O(n)</strong>。</p>
<p>不要以为for里放一个while就以为是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="904水果成篮">904.水果成篮</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮</a>：在一排树中，第 <code>i</code> 棵树产生 <code>tree[i]</code> 型的水果。</p>
<p>你可以<strong>从你选择的任何树开始</strong>，然后重复执行以下步骤：</p>
<ol>
<li>把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。</li>
<li>移动到当前树右侧的下一棵树。如果右边没有树，就停下来。</li>
</ol>
<p>请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</p>
<p>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。</p>
<p>用这个程序你能收集的水果树的最大总量是多少？</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：[0,1,2,2]
输出：3
解释：我们可以收集 [1,2,2]
如果我们从第一棵树开始，我们将只能收集到 [0, 1]。
</code></pre>
</blockquote>
<p>本题需要记录不同类型水果个数，使用哈希表当篮子。</p>
<p>本题中的窗口就是 两个装有不同类型水果的篮子。</p>
<p>窗口的起始位置如何移动：如果当前篮子数目<strong>大于2</strong>了，窗口就要向前移动了，同时依次减持水果，直到篮子数目重回2。</p>
<p>窗口的结束位置如何移动：窗口的<strong>结束位置就是遍历数组的指针</strong>，窗口的起始位置设置为数组的起始位置就可以了。</p>
<pre><code class="language-cpp">class Solution {
public:
    int totalFruit(vector&lt;int&gt;&amp; fruits) {
        unordered_map&lt;int, int&gt; basket;
        int result = 0, len = 0;
        int left = 0;
        for (int i = 0; i &lt; fruits.size(); i++) {
            basket[fruits[i]]++;
            len++;
            while (basket.size() &gt; 2) {
                basket[fruits[left]]--; //减掉left是因为采果子必须按顺序连续采
                if (basket[fruits[left]] == 0) basket.erase(fruits[left]); //直到某一个篮子为空
                left++;
                len--;
            }
            // 结束位置每移动一次，维护一次最大值
            result = max(result,len);
        }
        return result;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<h2 id="76最小覆盖子串">76.最小覆盖子串</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>： 给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>示例 ：</strong></p>
<pre><code>输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;
输出：&quot;BANC&quot;
</code></pre>
</blockquote>
<p>本题由于<code>t</code>中存在重复字符，需要通过计数，确定字符是否找齐。</p>
<p>用<code>j</code>,<code>i</code>表示滑动窗口的左边界和右边界，当这个窗口包含的元素满足条件，即包含字符串<code>t</code>的所有元素，记录下这个滑动窗口的长度<code>i-j+1</code>，这些长度中的最小值就是要求的结果。</p>
<p><strong>步骤一</strong><br>
不断增加<code>i</code>使滑动窗口增大，直到窗口包含了<code>t</code>的所有元素（通过计数判断）</p>
<p><strong>步骤二</strong><br>
不断增加<code>j</code>使滑动窗口缩小，因为是要求最小字串，所以将不必要的元素排除在外，使长度减小，直到碰到一个必须包含的元素，记录此时滑动窗口的长度，并保存最小值</p>
<p><strong>步骤三</strong><br>
让<code>j</code>再增加一个位置，这个时候滑动窗口肯定不满足条件了，那么继续从步骤一开始执行，寻找新的满足条件的滑动窗口，如此反复，直到<code>i</code>超出了字符串<code>s</code>范围。</p>
<pre><code class="language-cpp">class Solution {
public:
    string minWindow(string s, string t) {
        int n = s.size(), m = t.size();
        vector&lt;int&gt; hash(128);
        for (char c : t) hash[c]--;
        string res = &quot;&quot;;
        for (int i = 0, j = 0, cnt = 0; i &lt; n; i++) {
            hash[s[i]]++;
            // 计数，t中的字符有几个被找到
            if (hash[s[i]] &lt;= 0) cnt++;
            // 找齐之后，要缩减一次长度，移动起始位置
            while (cnt == m &amp;&amp; hash[s[j]] &gt; 0) hash[s[j++]]--;
            // 缩减之后，比较并存最短长度
            if (cnt == m){
                if (res == &quot;&quot; || res.size() &gt; i - j + 1){
                    res = &quot;&quot;;
                    // 取[j,i]的子字符串
                    for (int k = j; k &lt;= i; k++){
                        res += s[k];
                    }
                }
            }   
        }
        return res;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【牛客刷题】输入输出练习]]></title>
        <id>https://star2dust.github.io/post/leetcode-acm-io/</id>
        <link href="https://star2dust.github.io/post/leetcode-acm-io/">
        </link>
        <updated>2021-11-27T09:13:03.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%B8%A6%E7%A9%BA%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B4%E6%95%B0">带空格的字符串（整数）</a></li>
<li><a href="#%E5%B8%A6%E9%80%97%E5%8F%B7%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">带逗号的字符串</a></li>
</ul>
</p>
<p>牛客链接：https://ac.nowcoder.com/acm/contest/5657#question</p>
<h1 id="带空格的字符串整数">带空格的字符串（整数）</h1>
<blockquote>
<p>输入：</p>
<p>多个测试用例，每个测试用例一行。</p>
<p>每行通过空格隔开，有n个字符，n＜100</p>
</blockquote>
<blockquote>
<p>输出：</p>
<p>对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</p>
</blockquote>
<p>示例：</p>
<pre><code>input:
a c bb
f dddd
nowcoder

output:
a bb c
dddd f
nowcoder
</code></pre>
<p>C++：</p>
<pre><code class="language-cpp">//#include&lt;bits/stdc++.h&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

int main(){
    string s;
    vector&lt;string&gt; str;
    while (cin&gt;&gt;s){
        str.push_back(s);
        if (cin.get()=='\n'){
            sort(str.begin(),str.end());
            for (auto ss: str) cout &lt;&lt; ss &lt;&lt; &quot; &quot;;
            cout &lt;&lt; endl;
            str.clear();
        }
    }
    return 0;
}
</code></pre>
<p>可以看出，思路是【直接输入+判断换行】。</p>
<p>实际上只要是用空格分隔，都可以用这个模板，整数处理也一样。参考如下输出要求。</p>
<blockquote>
<p>输出：</p>
<p>对于每组测试用例，输出求和的结果。</p>
</blockquote>
<p>示例：</p>
<pre><code>input:
1 2 3
4 5
0 0 0 0 0

output:
6
9
0
</code></pre>
<p>C++：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

int main(){
    int a, sum = 0;
    while (cin &gt;&gt; a){
        sum += a;
        if (cin.get()=='\n'){
            cout &lt;&lt; sum &lt;&lt; endl;
            sum = 0;
        }
    }
    return 0;
}
</code></pre>
<h1 id="带逗号的字符串">带逗号的字符串</h1>
<p>还是上面的问题，所有的空格改为逗号。</p>
<blockquote>
<p>输入：</p>
<p>多个测试用例，每个测试用例一行。</p>
<p>每行通过<strong>逗号</strong>隔开，有n个字符，n＜100</p>
</blockquote>
<blockquote>
<p>输出：</p>
<p>对于每组测试用例，输出一行排序过的字符串，每个字符串通过<strong>逗号</strong>隔开</p>
</blockquote>
<p>示例：</p>
<pre><code>input:
a c bb
f dddd
nowcoder

output:
a bb c
dddd f
nowcoder
</code></pre>
<p>C++：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;sstream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

int main(){
    string s;
    vector&lt;string&gt; str;
    while (getline(cin,s)){
        stringstream ss(s);
        string tmp;
        while (getline(ss,tmp,',')){
            str.push_back(tmp);
        }
        sort(str.begin(),str.end());
        for (int i=0; i&lt;str.size(); i++){
            cout &lt;&lt; str[i];
            if (i==str.size()-1) {
                cout &lt;&lt; endl;
            }else{
                cout &lt;&lt; &quot;,&quot;;
            }
        }
        str.clear();
    }
    return 0;
}
</code></pre>
<p>由于不能直接判断换行，思路是先【读取整行】，再【按逗号分割】，后面都是一样的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【力扣刷题】和为奇数的子数组数目（前缀和）]]></title>
        <id>https://star2dust.github.io/post/leecode-subarrays-with-odd-sum/</id>
        <link href="https://star2dust.github.io/post/leecode-subarrays-with-odd-sum/">
        </link>
        <updated>2021-11-15T00:55:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum/">1524. 和为奇数的子数组数目</a>：给你一个整数数组 <code>arr</code> 。请你返回和为 <strong>奇数</strong> 的子数组数目。<br>
由于答案可能会很大，请你将结果对 <code>10^9 + 7</code> 取余后返回。</p>
</blockquote>
<blockquote>
<p>以下实例为小马智行（pony.ai）二面coding面试题。</p>
<p>输入：arr = [1,3,5]<br>
输出：4<br>
解释：所有的子数组为 [[1],[1,3],[1,3,5],[3],[3,5],[5]] 。<br>
所有子数组的和为 [1,4,9,3,8,5].<br>
奇数和包括 [1,9,3,5] ，所以答案为 4 。</p>
</blockquote>
<p>这里总结一下前缀和的算法思想。给定一个int arr[]数组，我们要计算第i项及以前的和, sum[i]表示从下标0到下标i的和，那么sum[i] = sum[i - 1] + arr[i]，这里的前缀和就是sum[i - 1]。也就是所记录的前缀和应该是[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]...这个样子。</p>
<p>参考<a href="https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum/solution/c-he-wei-qi-shu-de-zi-shu-zu-shu-mu-qian-zhui-he-b/">yuyangxianyi的题解</a>，如果当前和为奇数的话，例如[1, 2, 3, 4, 5], 计算到第5个数时<strong>和为奇数，我们只要减去前缀和为偶数的</strong>即可，例如减去[1, 2, 3], 这样这个序列就剩下[4, 5]是奇数，也是新增的项，还可以减去[1, 2, 3, 4], 剩下[5], 也是新增的一项，本质为：奇数 - 偶数 = 奇数，意思就是说，<strong>有几个偶前缀和，就新增几项</strong>。相反的，如果当前<strong>和为偶数，只需要减去所有奇数的前缀和</strong>，即为新增的数目，本质为：偶数 - 奇数 = 奇数。最后把当前的和是奇数，令前缀和为奇数的++, 反之亦然。</p>
<p>起初前缀和是偶数值为1是因为可以理解为默认一个0的存在。</p>
<pre><code class="language-cpp">class Solution {
public:
    typedef long long ll;
    #define mod 1000000007
    int numOfSubarrays(vector&lt;int&gt;&amp; arr) {
        //前缀和为0到i的arr和
        ll even_pre_sum = 1; // 可以理解为0 + pre_sum
        ll odd_pre_sum = 0;
        ll sum = 0;
        int ans = 0;
        for (int i = 0; i &lt; arr.size(); i++) {
            sum += arr[i];
            if (sum % 2) {//arr和为奇数
                //如果当前和为奇数，要减去前缀和为偶数的即可
                ans += even_pre_sum; //即有几个偶前缀和，就新增几项
                odd_pre_sum++;
            } else {
                ans += odd_pre_sum;
                even_pre_sum++;
            }
            ans %= mod;
        }
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【力扣刷题】排列小球（DFS）]]></title>
        <id>https://star2dust.github.io/post/leecode-arrange-balls/</id>
        <link href="https://star2dust.github.io/post/leecode-arrange-balls/">
        </link>
        <updated>2021-11-10T14:41:20.000Z</updated>
        <content type="html"><![CDATA[<p>力扣链接：https://leetcode-cn.com/leetbook/read/didiglobal2/e7hh2i/</p>
<p>给定三种类型的小球 P、Q、R，每种小球的数量分别为 np、nq、nr 个。现在想将这些小球排成一条直线，但是不允许相同类型的小球相邻，问有多少种排列方法。如果无法组合出合适的结果，则输出 0。</p>
<p>格式：</p>
<blockquote>
<p>输入：一行以空格相隔的三个数，分别表示为 np，nq，nr。<br>
输出：排列方法的数量。</p>
</blockquote>
<p>示例：</p>
<blockquote>
<p>输入：2 1 1<br>
输出：6<br>
解释：如若 np=2，nq=1，nr=1 则共有 6 种排列方式：PQRP，QPRP，PRQP，RPQP，PRPQ 以及 PQPR。</p>
</blockquote>
<p>解法：通过dfs递归求解。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

int dfs(int last_color, int np, int nq, int nr){
    // if balls of any color run out
    if (np&lt;0||nq&lt;0||nr&lt;0){
        return 0;
    }
    // if only one ball remains 
    if (np+nq+nr==1){
        if (last_color==0) return np;
        if (last_color==1) return nq;
        if (last_color==2) return nr;
    }else{ 
        // back to n-1
        if (last_color==0) return dfs(1,np-1,nq,nr)+dfs(2,np-1,nq,nr);
        if (last_color==1) return dfs(0,np,nq-1,nr)+dfs(2,np,nq-1,nr);
        if (last_color==2) return dfs(0,np,nq,nr-1)+dfs(1,np,nq,nr-1);
    }
    return 0;
}

int main(){
    int np, nq, nr;
    cin&gt;&gt;np&gt;&gt;nq&gt;&gt;nr;
    // 3 colors 
    int ans = dfs(0,np,nq,nr)+dfs(1,np,nq,nr)+dfs(2,np,nq,nr);
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>很不幸，上面的解法超时了，测试用例通过3/5，那么加个dp数组进行记忆化搜索。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
// 用int不够，改为long long
typedef long long LL;

LL p,q,r;

inline LL I(int c,int x,int y,int z){
    return c*(p+1)*(q+1)*(r+1)+x*(q+1)*(r+1)+y*(r+1)+z;
}

vector&lt;LL&gt; dp;

LL find(int c,int i,int j,int k){
    if(i&lt;0||j&lt;0||k&lt;0) return 0;
    LL idx=I(c,i,j,k);
    if(dp[idx]==-1){
        dp[idx]=0;
        if(c==0) dp[idx]+=find(1,i-1,j,k)+find(2,i-1,j,k);
        if(c==1) dp[idx]+=find(0,i,j-1,k)+find(2,i,j-1,k);
        if(c==2) dp[idx]+=find(0,i,j,k-1)+find(1,i,j,k-1);
    }
    return dp[idx];
}

int main(){
    cin&gt;&gt;p&gt;&gt;q&gt;&gt;r;
    dp.resize(3*(p+1)*(q+1)*(r+1));
    fill(dp.begin(),dp.end(),-1);
    dp[I(0,1,0,0)]=1;
    dp[I(1,0,1,0)]=1;
    dp[I(2,0,0,1)]=1;
    cout&lt;&lt;find(0,p,q,r)+find(1,p,q,r)+find(2,p,q,r)&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【力扣刷题】推多米诺（双指针）]]></title>
        <id>https://star2dust.github.io/post/leecode-domino/</id>
        <link href="https://star2dust.github.io/post/leecode-domino/">
        </link>
        <updated>2021-09-10T09:20:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://leetcode-cn.com/problems/push-dominoes/">838. 推多米诺</a>：一行中有 N 张多米诺骨牌，我们将每张多米诺骨牌垂直竖立。在开始时，我们同时把一些多米诺骨牌向左或向右推。每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。如果同时有多米诺骨牌落在一张垂直竖立的多米诺骨牌的两边，由于受力平衡， 该骨牌仍然保持不变。就这个问题而言，我们会认为正在下降的多米诺骨牌不会对其它正在下降或已经下降的多米诺骨牌施加额外的力。</p>
<p>给定表示初始状态的字符串 &quot;S&quot; 。如果第 i 张多米诺骨牌被推向左边，则 S[i] = 'L'；如果第 i 张多米诺骨牌被推向右边，则 S[i] = 'R'；如果第 i 张多米诺骨牌没有被推动，则 S[i] = '.'。</p>
<p>返回表示最终状态的字符串。</p>
</blockquote>
<blockquote>
<p>以下实例为小马智行（pony.ai）一面coding面试题。<br>
输入：&quot;.L.R...LR..L..&quot;<br>
输出：&quot;LL.RR.LLRRLL..&quot;</p>
<p>// INPUT:   |\ | /|||\ /||\ ||<br>
// OUTPUT:  \ | //|\ //\ ||</p>
</blockquote>
<pre><code class="language-cpp">class Solution {
public:
    string pushDominoes(string dominoes) {
        //左右加上LR不影响最终结果，可以避免判定.是否在两端
        dominoes = &quot;L&quot;+dominoes+&quot;R&quot;;
        string res = &quot;&quot;;
        int n = dominoes.length(); 
        //双指针
        int left = 0, right = 1;
        while (right&lt;n){
            if (dominoes[right]=='.') {
                //区块右边界更新
                right++;
                continue;
            }
            if (left&gt;0){
                //LR不会改变，会改变的只有.
                res += dominoes[left];
            }
            int block_size = right-left-1;//区块中的.部分，不包括两端
            if (dominoes[left]==dominoes[right]){
                //左右相同，倒向相同
                res += string(block_size, dominoes[left]);
            }else if (dominoes[left]=='L' &amp;&amp; dominoes[right]=='R'){//左右相异，分两种情况
                //左L右R，中间不变
                res += string(block_size,'.');
            }else{
                 //左R右L，二分点不变，左边变为R，右边变为L
                res += string(block_size/2,'R')+string(block_size%2,'.')+string(block_size/2,'L');
            }
            //区块左边界更新
            left = right;
            right++;
        }
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Turtlebot+Stage进行SLAM仿真（ROS Kinetic）]]></title>
        <id>https://star2dust.github.io/post/turtlebot-stage-slam/</id>
        <link href="https://star2dust.github.io/post/turtlebot-stage-slam/">
        </link>
        <updated>2021-08-19T11:34:40.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#stage%E4%BB%8B%E7%BB%8D">Stage介绍</a></li>
<li><a href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96">安装依赖</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8stage%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83">启动Stage仿真环境</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8slam">启动SLAM</a></li>
</ul>
</p>
<h1 id="stage介绍">Stage介绍</h1>
<p>Stage是Player/Stage项目的一个软件，是一种用于移动机器人和智能传感系统研究的仿真工具。</p>
<p>Stage在一个二维的位图环境下模拟移动机器人、传感器和障碍物等对象。Stage提供了多种传感器和执行器，包括声纳，激光扫描测距仪，色斑显示器，里程计，抓斗，防撞器/触须器以及移动机器人基座等。</p>
<p>Stage在设计中就考虑到了多智能体系统的问题，可以提供对多机器人系统的测试仿真。需要了解的是Stage只提供了真正简单，可计算的廉价的设备模式，而无法非常精密地仿真任何具体的设备终端。</p>
<h1 id="安装依赖">安装依赖</h1>
<p>首先可以尝试如下命令</p>
<pre><code class="language-shell">sudo apt-get install ros-kinetic-turtlebot*
</code></pre>
<p>安装完成后尝试运行</p>
<pre><code class="language-shell">export TURTLEBOT_STAGE_MAP_FILE=&quot;/opt/ros/kinetic/share/turtlebot_stage/maps/maze.yaml&quot;
export TURTLEBOT_STAGE_WORLD_FILE=&quot;/opt/ros/kinetic/share/turtlebot_stage/maps/stage/maze.world&quot;
roslaunch turtlebot_stage turtlebot_in_stage.launch
</code></pre>
<p>能够正常运行不报错即正常安装。</p>
<p>问题1：Rviz报错</p>
<pre><code>No transform from [wheel_left_link] to [map]
</code></pre>
<p>原因：未安装 joint_state_publisher_gui 功能包</p>
<p>运行命令安装</p>
<pre><code class="language-shell">sudo apt-get install ros-kinetic-joint-state-publisher-gui
</code></pre>
<p>参考：<a href="https://blog.csdn.net/caiguanhong/article/details/105347648">ROS问题—Rviz显示URDF模型时报错</a></p>
<h1 id="启动stage仿真环境">启动Stage仿真环境</h1>
<p>打开命令终端，和上节一样输入命令</p>
<pre><code class="language-shell">roslaunch turtlebot_stage turtlebot_in_stage.launch
</code></pre>
<p>turtlebot_stage 仿真分别启动了以下ros包：</p>
<ul>
<li>
<p>stage：仿真世界环境发布各种tf(transform)坐标关系，odom、base_scan等仿真数据</p>
</li>
<li>
<p>map_server：地图服务，加载其提供的仿真世界的地图</p>
</li>
<li>
<p>move_base：导航功能包，接收其他包的数据实现导航功能，调用A*、DWA实现路径规划</p>
</li>
<li>
<p>static map：静态地图</p>
</li>
<li>
<p>amcl：激光定位程序，通过粒子滤波算法实现机器人的实时定位</p>
</li>
<li>
<p>rviz view：Rviz可视化显示机器人状态、传感器数据、导航路线、costmap、设定导航目标点</p>
</li>
</ul>
<p>启动后会显示三个窗口，分别是Stage、rviz和joint_state_publisher，参考：<a href="https://blog.csdn.net/xingdou520/article/details/83716353">Turtlbot仿真之Stage</a></p>
<p>在rviz界面，点击菜单栏的【2D Nav Goal】 然后在图书中选择一个位置点击鼠标左键并拖到鼠标设定方向终点机器人的方向。</p>
<p>会发现机器人自动设定了全局路径，并启用DWA算法自动导航到设定的目标位置。</p>
<h1 id="启动slam">启动SLAM</h1>
<p>通过键盘控制机器人</p>
<pre><code class="language-shell">roslaunch turtlebot_teleop keyboard_teleop.launch
</code></pre>
<p>启动之后，看终端里的提示进行操作。u、i、o分别代表左转、前进、右转。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【力扣刷题】求和问题（二分查找+双指针）]]></title>
        <id>https://star2dust.github.io/post/leecode-num-sum/</id>
        <link href="https://star2dust.github.io/post/leecode-num-sum/">
        </link>
        <updated>2021-08-15T09:37:09.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">两数之和</a></li>
<li><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8Cii">两数之和II</a></li>
<li><a href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">三数之和</a></li>
<li><a href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C">四数之和</a></li>
</ul>
</p>
<p>本文总结力扣上的求和问题。</p>
<ul>
<li>
<p><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></p>
</li>
</ul>
<h1 id="两数之和">两数之和</h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a>：给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <code>target</code>  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p>
</blockquote>
<p>两数之和的求解是<strong>哈希表</strong>的经典用法。如果我们直接使用二重循环枚举，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。用哈希表可以省下一个循环的开销，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，代价是空间复杂度变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>​。</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int,int&gt; ump;//定义哈希表
        for (int i = 0; i &lt; nums.size(); i++){
            if (ump.count(target - nums[i])){//一旦target - nums[i]是哈希表的key，则配对成功
                return{ i, ump[target - nums[i]] };//返回对应的下标即可
            }
            ump[nums[i]] = i;//以nums[i]为key，以i为value存哈希表
        }
        return {-1,-1};
    }
};
</code></pre>
<h1 id="两数之和ii">两数之和II</h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a>：给定一个已按照 <strong>升序排列</strong>  的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。<code>numbers</code> 的下标 从 1 开始计数 ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code>。</p>
<p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
</blockquote>
<p>两数之和II是<strong>二分查找</strong>的经典用法。需要遍历数组一次确定第一个数，时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，寻找第二个数使用二分查找，时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，因此总时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        for (int i = 0; i &lt; numbers.size(); ++i) {
            int low = i + 1, high = numbers.size() - 1;
            while (low &lt;= high) {//注意这里有等号，low==high可能一开始就成立
                int mid = (high + low) / 2;
                if (numbers[mid] == target - numbers[i]) {//==
                    return {i + 1, mid + 1};
                } else if (numbers[mid] &gt; target - numbers[i]) {//&gt;
                    high = mid - 1;
                } else {//&lt;
                    low = mid + 1;
                }
            }
        }
        return {-1, -1};
    }
};
</code></pre>
<p>此外，我们还可以使用<strong>双指针</strong>。从两端逐渐向中间移动，直到成功配对，两个指针移动总次数最多为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，空间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        int low = 0, high = numbers.size() - 1;
        while (low &lt; high) {
            int sum = numbers[low] + numbers[high];
            if (sum == target) {
                return {low + 1, high + 1};
                //从两端逐渐向中间移动，直到成功配对
            } else if (sum &lt; target) {
                ++low;
            } else {
                --high;
            }
        }
        return {-1, -1};
    }
};
</code></pre>
<h1 id="三数之和">三数之和</h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a>：给你一个包含 n 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<p>本题和【两数之和】类似，但是难度高了不少。难点有二，一是少循环，二是去重复。</p>
<p>为保证不重复，我们首先进行<strong>排序</strong>，然后要求枚举过程满足：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi><mo>&lt;</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a&lt;b&lt;c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>严格成立；</li>
<li>需要和上一次枚举的数不相同。</li>
</ol>
<p>为了减少时间复杂度，仅对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>进行枚举，对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>使用<strong>双指针</strong>查找。</p>
<p>当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>减少到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。为什么是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，均摊下来，每次也向左移动一个位置，因此时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>​。</p>
<p>注意到我们的代码中还有第一重循环，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，因此枚举的总时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。由于排序的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，在渐进意义下小于前者，因此算法的总时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​。</p>
<p>我们忽略存储答案的空间，额外的排序的空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。然而我们修改了输入的数组 <code>nums</code>，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 <code>nums</code> 的副本并进行排序，空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;int&gt;&gt; ans;
        // 枚举 a
        for (int first = 0; first &lt; n; ++first) {
            // 需要和上一次枚举的数不相同
            if (first &gt; 0 &amp;&amp; nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            int third = n - 1;
            int target = -nums[first];
            // 枚举 b
            for (int second = first + 1; second &lt; n; ++second) {
                // 需要和上一次枚举的数不相同
                if (second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1]) {
                    continue;
                }
                // 需要保证 b 的指针在 c 的指针的左侧
                while (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) {
                    --third;//随b递增，c是递减的，不需要每个循环初始化third=n-1
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    ans.push_back({ nums[first], nums[second], nums[third] });
                }
            }
        }
        return ans;
    }
};
</code></pre>
<h1 id="四数之和">四数之和</h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a>：给你一个由 n 个整数组成的数组 <code>nums</code>，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> ：</p>
<ul>
<li>
<p><code>0 &lt;= a, b, c, d &lt; n</code></p>
</li>
<li>
<p>a、b、c 和 d 互不相同</p>
</li>
<li>
<p><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></p>
</li>
</ul>
<p>你可以按 任意顺序 返回答案 。</p>
</blockquote>
<p>本题和【三数之和】类似，解法也相似。<strong>即先排序，再两重循环枚举a、b，最后双指针c、d。</strong></p>
<p>两重循环格式：</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; length - 3; i++) {
    for (int j = i + 1; j &lt; length - 2; j++) {
        ...
    }
}
</code></pre>
<p>使用两重循环分别枚举前两个数，然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数。假设两重循环枚举到的前两个数分别位于下标 i 和 j，其中 i&lt;j。初始时，左右指针分别指向下标 j+1和下标 n−1。每次计算四个数的和，并进行如下操作：</p>
<ul>
<li>
<p>如果和等于 target，则将枚举到的四个数加到答案中，然后将左指针右移直到遇到不同的数，将右指针左移直到遇到不同的数；</p>
</li>
<li>
<p>如果和小于 target，则将左指针右移一位；</p>
</li>
<li>
<p>如果和大于target，则将右指针左移一位。</p>
</li>
</ul>
<p>使用双指针枚举剩下的两个数的时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>​，因此总时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​，低于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>4</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​。</p>
<p>具体实现时，还可以进行一些<strong>剪枝</strong>操作：</p>
<ul>
<li>在确定第一个数之后，如果 <code>nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target</code>，说明此时剩下的三个数无论取什么值，四数之和一定大于 target，因此退出第一重循环；</li>
<li>在确定第一个数之后，如果<code>nums[i]+nums[n-1]+nums[n-2]+nums[n-3]&lt;target</code>，说明此时剩下的三个数无论取什么值，四数之和一定小于 target，因此第一重循环直接进入下一轮；</li>
<li>在确定前两个数之后，如果 <code>nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target</code>，说明此时剩下的两个数无论取什么值，四数之和一定大于target，因此退出第二重循环；</li>
<li>在确定前两个数之后，如果<code>nums[i]+nums[j]+nums[n-1]+nums[n-2]&lt;target</code>，说明此时剩下的两个数无论取什么值，四数之和一定小于 target，因此第二重循环直接进入下一轮。</li>
</ul>
<p>额外的排序的空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，此外修改了输入的数组 <code>nums</code>，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 <code>nums</code> 的副本并进行排序，空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;vector&lt;int&gt;&gt; quadruplets;
        if (nums.size() &lt; 4) {
            return quadruplets;
        }
        sort(nums.begin(), nums.end());
        int length = nums.size();
        for (int i = 0; i &lt; length - 3; i++) {
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {
                continue;
            }
            long long sumTemp = (long long)nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3];
            //sumTemp防止int爆了
            if (sumTemp &gt; target) {
                break;//剪枝1
            }
            if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) {
                continue;//剪枝2
            }
            for (int j = i + 1; j &lt; length - 2; j++) {
                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) {
                    continue;
                }
                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) {
                    break;//剪枝3
                }
                if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) {
                    continue;//剪枝4
                }
                int left = j + 1, right = length - 1;
                while (left &lt; right) {
                    int sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        quadruplets.push_back({nums[i], nums[j], nums[left], nums[right]});
                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) {
                            left++;
                        }
                        left++;//左指针右移直到遇到不同的数
                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) {
                            right--;
                        }
                        right--;//右指针左移直到遇到不同的数
                    } else if (sum &lt; target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        return quadruplets;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[静态指针与指向静态类型的指针]]></title>
        <id>https://star2dust.github.io/post/const-ptr-and-ptr-to-const/</id>
        <link href="https://star2dust.github.io/post/const-ptr-and-ptr-to-const/">
        </link>
        <updated>2021-08-14T08:53:17.000Z</updated>
        <content type="html"><![CDATA[<p>当将const与指针一起使用的时候，一般有两种情况，const被应用到指针指向的那个东西，或者const被应用到存储在指针中的内存地址。</p>
<h1 id="第一种情况pointer-to-const">第一种情况：pointer to const</h1>
<p>注意：const修饰符绑定到离他最近的那个东西上。</p>
<pre><code class="language-c++">const int* u; 
</code></pre>
<p>这里u是一个指针，指向一个const int。即为 (const int) (*u);</p>
<p>也就是说u不是静态的，所以它不需要初始化。</p>
<p>但需要注意：</p>
<pre><code class="language-c++">int const* v;
</code></pre>
<p>这个表达方式与上面的那个表达式其实是一个意思！即 (int const) *v;</p>
<p>上面的两种情况会造成理解上的混乱，所以在实际的工作过程中应该坚持只使用第一种写法。</p>
<h1 id="第二种情况const-pointer">第二种情况：const pointer</h1>
<p>要使指针本身变成const，你必须将const修饰符放在*的右边，如下所示：</p>
<pre><code class="language-c++">int d =1;
int* const w = &amp;d;
</code></pre>
<p>w是一个指针，它是const的，指向一个int类型。由于w是静态的，所以必须初始化。</p>
<p>但现在d是可变的：</p>
<pre><code class="language-c++">d=2；
*w=3;
</code></pre>
<p>如果你不想指向的内容变化，可以：</p>
<pre><code class="language-c++">int d =1;
const int* const x = &amp;d;
int const* const x2=&amp;d;
</code></pre>
<p>现在指针和指向的对象都不能变了，但请注意，只是x与x2的指向和内容不能变了，d还是可以赋值的。</p>
<h1 id="实例">实例</h1>
<p>下面是一个实例。</p>
<pre><code class="language-c++">//*其实是与标示符结合的，虽然我们写成int a;实际上写成int *a;更接近实际。
int d = 1;
int* const w = &amp;d;
const int* const x = &amp;d;
int const* const x2 = &amp;d;
const int* u;
int const* v;
//*u = *x =&gt; error, *u is read only.
</code></pre>
<p>你能将一个non-const的对象的地址赋给一个const的指针，但你不能将一个const的对象的地址赋给一个non-const的指针！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【力扣刷题】深度/广度优先搜索算法思路解析和标准模板]]></title>
        <id>https://star2dust.github.io/post/leecode-dfs-bfs-template/</id>
        <link href="https://star2dust.github.io/post/leecode-dfs-bfs-template/">
        </link>
        <updated>2021-07-26T01:42:38.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</a></li>
<li><a href="#%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">深度/广度优先搜索算法</a>
<ul>
<li><a href="#%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF">两种算法标准模板</a></li>
<li><a href="#797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%B3%95%E4%B8%80">797. 所有可能的路径（解法一）</a></li>
</ul>
</li>
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">深度优先搜索的递归回溯算法</a>
<ul>
<li><a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">回溯算法</a></li>
<li><a href="#797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%B3%95%E4%BA%8C">797. 所有可能的路径（解法二）</a></li>
</ul>
</li>
<li><a href="#dijkstra%E7%AE%97%E6%B3%95">Dijkstra算法</a>
<ul>
<li><a href="#%E5%B8%A6%E5%A4%87%E5%BF%98%E5%BD%95%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">带备忘录的广度优先搜索算法</a></li>
<li><a href="#dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF">Dijkstra算法模板</a></li>
<li><a href="#743-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4">743. 网络延迟时间</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="问题描述">问题描述</h1>
<p>给定一个<strong>图</strong>(graph)，已知起始点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>和目标点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>，搜索图产生一条<strong>搜索树</strong>(search tree)，那么反向查找即可找到一条从起始点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>到目标点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>​的路径。</p>
<img src="https://star2dust.github.io/post-images/1627265150549.png" style="zoom: 50%;" />
<p>问题难点在于，如何构建这个搜索树？需要思考几个问题：</p>
<ul>
<li>是否一定要构建一整个搜索树？如果不是，我们需要遍历哪些点？</li>
<li>搜索终止条件是什么？如果图是环形的怎么办？</li>
<li>如何尽快找到目标点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>？</li>
</ul>
<p>为了解决这几个问题，我们提出<strong>容器</strong>(container)的概念。如果不需要遍历所有节点，那么只将需要遍历的点放入容器中，容器初始状态放入起始点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>。搜索终止条件就很明显了，当容器为空即终止。那么图是环形的怎么办呢？我们需要定义一个备忘录，标记以访问节点和未访问节点，避免重复搜索。</p>
<h1 id="深度广度优先搜索算法">深度/广度优先搜索算法</h1>
<p>深度优先搜索算法(depth first search)和广度优先搜索算法(breadth first search)用于解决构建搜索树问题的两种算法，他们的区别在于容器的不同。</p>
<img src="https://star2dust.github.io/post-images/1627265942074.png" style="zoom: 50%;" />
<p>深度优先搜索算法的策略是：移除/扩展容器中最深的节点，即后入先出(last in first out)。</p>
<img src="https://star2dust.github.io/post-images/1627267339863.png" style="zoom: 50%;" />
<p>广度优先搜索算法的策略是：移除/扩展容器中最浅的节点，即先入先出(first in first out)。</p>
<img src="https://star2dust.github.io/post-images/1627267555658.png" style="zoom: 50%;" />
<h2 id="两种算法标准模板">两种算法标准模板</h2>
<p>广度/深度优先搜索算法标准模板：</p>
<pre><code class="language-cpp">void bfs(邻接表, 起始节点, 目标节点)/*dfs(邻接表, 起始节点, 目标节点)*/{
    定义队列/*堆栈*/;
    定义备忘录，用于记录已经访问的节点;//如果图是树结构，则不需要备忘录
    将全部起始节点加入到队列/*堆栈*/中（空路径后加该节点）;
    更新备忘录；//必须加入时更新备忘录
    while (队列不为空){
        获取当前队列(当前层级)中的节点个数；//必须在这里读队列长度，因为后面队列长度会变
        for (该层所有节点){
            复制当前节点；
            出队/*出栈*/当前节点；
            for (全部目标节点){//最关键的循环终止条件
                if (当前节点==当前目标节点){
                    存当前路径；
                    继续/返回；//只需一条路径用返回，多条用继续
                }
            }
            for (邻接节点：邻接表[当前节点]){
                if (邻接节点可行且未访问过){
                    //如果入队时不更新备忘录，此时有可能又搜到上层节点
					加入该邻接节点到队列/*堆栈*/（当前路径后加该邻接节点）；
                    更新备忘录；
                }
            }
        }
    }
    遍历完毕，返回；
}
</code></pre>
<p>由于广度优先和深度优先仅取决于容器的不同，所以上面以广度优先搜索为基础，用注释符号标注出了深度优先不同于广度优先的地方。</p>
<p>注意：该标注模版仅能保证<strong>完全遍历</strong>，但搜索的路径是否满足要求需要具体分析。</p>
<h2 id="797-所有可能的路径解法一">797. 所有可能的路径（解法一）</h2>
<p>接下来以力扣题<a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a>为例，给出广度/深度优先搜索的题解。</p>
<blockquote>
<p>给你一个有 n 个节点的 <strong>有向无环图</strong>（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）</p>
<p>二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。</p>
<p>译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。</p>
</blockquote>
<blockquote>
<p>以下实例为我手撕的面试题，可惜没当场撕出来。</p>
<p>该题指定了起始点为{0,3}，目标点为{7,8} ，输出{0,3}到{7,8}的所有路径。</p>
<p>输入实例：{{1,2},{5},{5},{4},{6},{7,8},{8},{},{}}</p>
<p>输出实例：{{0,1,5,7},{0,1,5,8},{0,2,5,7},{0,2,5,8},{3,4,6,8}}</p>
<p>0   3<br>
/ \  |<br>
1 2 4<br>
\ /  |<br>
5   6<br>
/ \ /<br>
7  8</p>
</blockquote>
<p>注意到该题为无环图，因此解法等同于<strong>层序遍历多叉森林</strong>，无需备忘录，而终止条件并非为了终止循环，而是为了记录路径。</p>
<pre><code class="language-cpp">//用于入队、入栈的节点结构
struct Node{
    int id;
    vector&lt;int&gt; path;
    
    Node(int id){
        this-&gt;id = id;
        this-&gt;path = {id};
    }
    
    Node(int id, vector&lt;int&gt; path){
        this-&gt;id = id;
        this-&gt;path = path;
        this-&gt;path.push_back(id);
    }
};
// 广度优先搜索
vector&lt;vector&lt;int&gt;&gt; bfs(vector&lt;vector&lt;int&gt;&gt; graph, vector&lt;int&gt; start, vector&lt;int&gt; goal){
    queue&lt;Node&gt; q;
    vector&lt;vector&lt;int&gt;&gt; results;
    int depth = 0;
    for (int s: start) q.push(Node(s));
    while (!q.empty()){
        int n = q.size();
        for (int i=0; i&lt;n; i++){
            Node p = q.front();
            q.pop();
            for (int g: goal){
               if (p.id==g){
                    results.push_back(p.path);
                    continue;
                } 
            }
            for (int next: graph[p.id]){
                q.push(Node(next,p.path));
            }
        }
        depth++;
    }  
    return results;
}
// 深度优先搜索
vector&lt;vector&lt;int&gt;&gt; dfs(vector&lt;vector&lt;int&gt;&gt; graph, vector&lt;int&gt; start, vector&lt;int&gt; goal){
    stack&lt;Node&gt; q;//区别1
    vector&lt;vector&lt;int&gt;&gt; results;
    int step = 0;
    for (int s: start) q.push(Node(s));
    while (!q.empty()){
        int n = q.size();
        for (int i=0; i&lt;n; i++){
            Node p = q.top();//区别2
            q.pop();
            for (int g: goal){
               if (p.id==g){
                    results.push_back(p.path);
                    continue;
                } 
            }
            for (int next: graph[p.id]){
                q.push(Node(next,p.path));
            }
        }
        step++;
    }  
    return results;
}
int main() {
    vector&lt;vector&lt;int&gt;&gt; graph = {{1,2},{5},{5},{4},{6},{7,8},{8},{},{}};
    vector&lt;int&gt; start = {0,3};
    vector&lt;int&gt; goal = {7,8};
    vector&lt;vector&lt;int&gt;&gt; paths;
    paths = bfs(graph,start,goal);
    // paths = dfs(graph,start,goal);
    return 0;
}
</code></pre>
<h1 id="深度优先搜索的递归回溯算法">深度优先搜索的递归回溯算法</h1>
<p>深度优先搜索算法也可以按照递归写，模板如下：</p>
<pre><code class="language-cpp">void dfs(当前节点){
    if (当前节点==目标节点){
        返回；//找到即返回
    }
    for (当前节点的所有下层节点){
        dfs(下层节点)；//对子树做dfs
    }
}
void main(){
    判断边界条件，是否能直接返回;
    dfs(起始节点)；
    遍历完毕，返回；    
}
</code></pre>
<p>通过上述模板，可以实现多叉森林中所有点的遍历，但是会出现重复遍历的现象。相当于搜的过程中发现此路不通，于是走了回头路。</p>
<p>那么问题来了，如果需要存路径，则必须删除这些回头路，怎么办？于是有了下面的回溯算法。</p>
<h2 id="回溯算法">回溯算法</h2>
<p><strong>回溯算法</strong>(back tracking)也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。</p>
<p>回溯算法的模板与上面深度优先搜索算法模板几乎完全一致，区别在于递归函数的前后分别有节点处理和撤销处理的两个操作。</p>
<p>回溯算法标准模板：</p>
<pre><code class="language-cpp">void backTracking(当前节点){
    if (当前节点==目标节点){
        存当前路径；
        返回；//找到即返回
    }
    for (当前节点的所有下层节点){
        当前节点加入路径；//节点处理
        backTracking(下层节点)；//对子树做bt
        路径中撤销当前节点；//撤销处理
    }
}
void main(){
    判断边界条件，是否能直接返回;
    backTracking(起始节点)；
    遍历完毕，返回；    
}
</code></pre>
<p>回溯算法中，<strong>for循环可以理解是横向遍历，backTracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了。</p>
<h2 id="797-所有可能的路径解法二">797. 所有可能的路径（解法二）</h2>
<p>这里用深度优先递归回溯方法解决力扣题<a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a>。</p>
<pre><code class="language-cpp">void dfsbt(vector&lt;vector&lt;int&gt;&gt;&amp; paths, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt; graph, int start, int goal){
    if (start==goal){
        paths.push_back(path);
        return;
    }
    for (int next: graph[start]){
        path.push_back(next);
        dfsbt(paths,path,graph,next,goal);
        path.pop_back();//撤销处理
    }
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; graph = {{1,2},{5},{5},{4},{6},{7,8},{8},{},{}};
    vector&lt;int&gt; start = {0,3};
    vector&lt;int&gt; goal = {7,8};
    vector&lt;vector&lt;int&gt;&gt; paths;
    // 与bfs每一个节点复制并维持一条路径不同，dfs有几条可行路径就维持几条
    for (int s: start){
        for (int g: goal){
            vector&lt;int&gt; path = {s};
            dfsbt(paths,path,graph,s,g);
        }
    }
    return 0;
}
</code></pre>
<h1 id="dijkstra算法">Dijkstra算法</h1>
<p>前面考虑的是<strong>有向无环无权图</strong>，bfs搜索中不会出现重复遍历，变量<code>depth</code>直接记录了路径的长度。</p>
<p>但是对于<strong>有向有环加权图</strong>，输出所有路径是不可能的，因为环的存在，每个节点能够重复遍历，所以路径有无数条。</p>
<p>为了解决环的问题，必须在bfs中引入<strong>备忘录</strong>，可以套用前面的模板，把bfs算法扩展到有向有环图上。</p>
<h2 id="带备忘录的广度优先搜索算法">带备忘录的广度优先搜索算法</h2>
<p>还是以力扣题<a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a>为例，结合前面的模板，给出以下题解。</p>
<pre><code class="language-cpp">// 带备忘录的广度优先搜索
vector&lt;vector&lt;int&gt;&gt; bfsv(vector&lt;vector&lt;int&gt;&gt; graph, vector&lt;int&gt; start, vector&lt;int&gt; goal){
    queue&lt;Node&gt; q;
    vector&lt;vector&lt;int&gt;&gt; results;
    vector&lt;int&gt; visited(graph.size());//备忘录
    int depth = 0;
    for (int s: start) {
        q.push(Node(s));
        visited[s] = 1;//入队加备忘
    }
    while (!q.empty()){
        int n = q.size();
        cout&lt;&lt;depth&lt;&lt;&quot; - &quot;;
        for (int i=0; i&lt;n; i++){
            Node p = q.front();
            q.pop();
            cout&lt;&lt;p.id&lt;&lt;&quot; &quot;;
            for (int g: goal){
               if (p.id==g){
                    results.push_back(p.path);
                    continue;
                } 
            }
            for (int next: graph[p.id]){
                if (!visited[next]){
                    q.push(Node(next,p.path));
                    visited[next] = 1;//入队加备忘
                }                
            }
        }
        depth++;
        cout&lt;&lt;endl;
    }  
    return results;
}
int main() {
    // [4,2,5,6,4]、[4,6,4]形成环
    vector&lt;vector&lt;int&gt;&gt; graph = {{1,2},{5},{5},{4},{2,6},{6,7,8},{4,8},{},{}};
    vector&lt;int&gt; start = {0,3};
    vector&lt;int&gt; goal = {7,8};
    cout&lt;&lt;&quot;算法的遍历顺序：&quot;&lt;&lt;endl;
    vector&lt;vector&lt;int&gt;&gt; paths;
    paths = bfsv(graph,start,goal);
    cout&lt;&lt;&quot;输出的路径：&quot;&lt;&lt;endl;
    for (auto p: paths) {
        for (int n: p) cout&lt;&lt;n&lt;&lt;&quot; &quot;; 
        cout&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<p>得到的输出如下：</p>
<pre><code class="language-shell">算法的遍历顺序：
0 - 0 3 
1 - 1 2 4 
2 - 5 6 
3 - 7 8 
输出的路径：
0 1 5 7 
0 1 5 8 
</code></pre>
<p>可以看出，对于有环图，在原有bfs算法引入备忘录可以保证将所有节点不重复的全部遍历一遍。</p>
<p>但是，由于备忘录的存在，节点无法重复遍历，输出的路径变少了。</p>
<h2 id="dijkstra算法模板">Dijkstra算法模板</h2>
<p>针对有向有环加权图，考虑边的权值，Dijkstra算法解决两点之间最小权值和的路径，即距离最短路径。</p>
<p>Dijkstra算法标准模板：</p>
<pre><code class="language-cpp">数组 dijkstra(邻接表, 起始节点, 目标节点){
    定义dp数组，记录起始节点到所有节点的距离，初始化为正无穷；
    dp[起始节点]=0；
    定义优先队列，按照距离由小到大排序;
    将[起始节点,起始节点距离(0)]加入到优先队列中;
    while (优先队列不为空){
        [当前节点,当前节点距离]=优先队列前端节点；
        出队优先队列前端节点；
        if (当前节点==目标节点){//循环终止条件（可选）
            返回当前节点距离；
        }
        if (当前节点距离&gt;dp[当前节点]){//循环继续条件
             继续；
        }
        for (当前节点的所有邻居节点){
            邻居节点经过当前节点到初始节点的距离=dp[当前节点]+当前节点与邻居节点之间的边权值；
            if (dp[邻居节点]&gt;邻居节点经过当前节点到初始节点的距离){
                //更新dp数组
                dp[邻居节点]=邻居节点经过当前节点到初始节点的距离;
                将[邻居节点，dp[邻居节点]]加入到优先队列中；
            }
        }
    }
    遍历完毕，返回dp数组；
}
</code></pre>
<h2 id="743-网络延迟时间">743. 网络延迟时间</h2>
<p>接下来以力扣题[<a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a>为例，给出Dijkstra算法的题解。</p>
<blockquote>
<p>有 n 个网络节点，标记为 1 到 n。</p>
<p>给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。</p>
<p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。</p>
</blockquote>
<pre><code class="language-cpp">int networkDelayTime(vector&lt;vector&lt;int&gt;&gt; &amp;times, int n, int k) {
    const int inf = INT_MAX / 2;
    //建图，得到邻接表
    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);
    for (auto &amp;t : times) {
        int x = t[0] - 1, y = t[1] - 1;//-1是因为编号起始于1
        graph[x].emplace_back(t[2],y);//第一个是权值，第二个是邻居节点
    }
    // 记录最短路径的权重，你可以理解为 dp table
    vector&lt;int&gt; dist(n, inf);
    // base case，start 到 start 的最短距离就是 0
    dist[k - 1] = 0;
    // 优先级队列，distFromStart 较小的排在前面
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; q;
    // 从起点 start 开始进行 BFS
    q.emplace(0, k - 1);
    while (!q.empty()) {
        auto p = q.top();
        q.pop();
        int time = p.first, x = p.second;
        if (dist[x] &lt; time) {
            // 已经有一条更短的路径到达 curNode 节点了
            continue;
        }
        // 将 curNode 的相邻节点装入队列
        for (auto &amp;edge : graph[x]) {
            // 看看从 curNode 达到 nextNode 的距离是否会更短
            int y = edge.second, d = dist[x] + edge.first;
            if (d &lt; dist[y]) {
                // 更新 dp table
                dist[y] = d;
                // 将这个节点以及距离放入队列
                q.emplace(d, y);
            }
        }
    }
    // max_element返回地址指针
    int ans = *max_element(dist.begin(), dist.end());
    return ans == inf ? -1 : ans;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【力扣刷题】动态规划问题的思考与总结]]></title>
        <id>https://star2dust.github.io/post/leecode-dynamic-programming/</id>
        <link href="https://star2dust.github.io/post/leecode-dynamic-programming/">
        </link>
        <updated>2021-07-21T13:37:54.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">什么是动态规划</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E6%AD%A5%E9%AA%A4">解决动态规划问题的步骤</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E9%80%92%E6%8E%A8%E7%AE%97%E6%B3%95">基础递推算法</a>
<ul>
<li><a href="#%E5%AD%90%E9%97%AE%E9%A2%98%E6%B1%82%E5%92%8C">子问题求和</a>
<ul>
<li><a href="#%E7%88%AC%E6%A5%BC%E6%A2%AF">爬楼梯</a></li>
<li><a href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92">杨辉三角</a></li>
</ul>
</li>
<li><a href="#%E5%AD%90%E9%97%AE%E9%A2%98%E6%9C%80%E5%80%BC">子问题最值</a>
<ul>
<li><a href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C">最大子序和</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%84">二维DP数组</a></li>
<li><a href="#%E9%9D%9E%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84">非最优子结构</a></li>
</ul>
</li>
<li><a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E5%A4%9A%E7%8A%B6%E6%80%81%E9%80%92%E6%8E%A8">买卖股票（多状态递推）</a></li>
<li><a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95">打家劫舍（分治算法）</a></li>
<li><a href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a></li>
<li><a href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">背包问题</a></li>
</ul>
</p>
<h1 id="什么是动态规划">什么是动态规划</h1>
<p>动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
<ul>
<li>什么样的题目需要用动态规划？</li>
</ul>
<p>动态规划要解决的都是一些问题的<strong>最优解</strong>，即从很多解决问题的方案中找到最优的一个。以<a href="https://leetcode-cn.com/study-plan/dynamic-programming/">力扣动态规划专题</a>为例，题目都是形如最长数组长度、最小花费、最大和等。当我们在求一个问题最优解的时候，可以把这个问题分解成多个子问题，然后递归地找到每个子问题的最优解，最后通过一定的数学方法对各个子问题的最优解进行组合得出最终的结果。总结来说就是一个问题的最优解是由它的各个子问题的最优解决定的。</p>
<p><strong>将子问题的解进行组合可以得到原问题的解是动态规划可行性的关键。<strong>即存在最优子结构，实际上不一定所有的问题的解都能被直接写为子问题的组合。在解题中一般用</strong>状态转移方程</strong>描述这种组合。例如原问题的解为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，即状态。状态转移方程形如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n) = f(n - 1) + f(n - 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，即斐波拉契数列递推公式，描述了一种原问题与子问题的组合关系 。找到了<strong>最优子结构</strong>，也就能推导出一个状态转移方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，通过这个状态转移方程，我们能很快的写出问题的递归实现方法。</p>
<ul>
<li>为什么不用递归？</li>
</ul>
<p>当我们在递归地寻找每个子问题的最优解的时候，有可能会重复地遇到一些更小的子问题，而且这些子问题会重叠地出现在子问题里，出现这样的情况，会有很多重复的计算，<strong>动态规划可以保证每个重叠的子问题只会被求解一次</strong>。当重复的问题很多的时候，动态规划可以减少很多重复的计算。</p>
<p>去掉重复子问题不是保证解的正确性必须的，但是如果递归求解子问题时，没有出现重复子问题，则没有必要用动态规划，直接普通的递归就可以了。</p>
<ul>
<li>解决动态规划问题的核心</li>
</ul>
<p>解决动态规划问题的核心是<strong>找出子问题及其子问题与原问题的关系</strong>。</p>
<p>动态规划算法中关于最优子结构和重复子问题的理解的关键点：</p>
<ol>
<li>证明问题的方案中包含<strong>一种选择</strong>，选择之后留下一个或多个子问题；</li>
<li>设计子问题的<strong>递归</strong>描述方式；</li>
<li>证明对原问题的最优解包括了对所有子问题的最优解；</li>
<li>证明子问题是重叠的（这一步不是动态规划正确性必需的，但是如果子问题无重叠，则效率与一般递归是相同的）。</li>
</ol>
<h1 id="解决动态规划问题的步骤">解决动态规划问题的步骤</h1>
<p>动态规划有两种计算顺序，一种是自顶向下的、使用备忘录（记忆化）的递归方法，一种是自底向上的、使用DP数组（滚动数组）的循环方法。不过在普通的动态规划题目中，99% 的情况我们都不需要用到备忘录方法，所以我们最好坚持用自底向上的DP数组。同时备忘录方法的空间复杂度会比较高。</p>
<ul>
<li>自顶向下</li>
</ul>
<p>递归的解法需要非常多的重复计算，如果有一种办法能<strong>避免这些重复计算</strong>，可以节省大量计算时间。记忆化就是基于这个思路的算法。在递归地求解子问题<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>... 过程中，将结果保存到一个表里，在后续求解子问题中如果遇到求过结果的子问题，直接查表去得到答案而不计算。</p>
<ul>
<li>自底向上</li>
</ul>
<p>有了状态转移方程，我们就知道如何从最小的问题规模入手，然后不断地增加问题规模，直到所要求的问题规模为止。在这个过程中，我们可以从小到大记忆每个问题规模的解来避免重复的计算。这种方法就是自底向上的方法，由于避免了递归，这是一种更好的办法。</p>
<p>但是迭代法需要有一个明确的迭代方向，例如线性，区间，树形，状态压缩等比较主流的动态规划问题中，迭代方向都有相应的模式。但是有一些问题迭代法方向是不确定的，这时可以退而求其次用记忆化来做。</p>
<p>动态规划自底向上的四个解题步骤是：</p>
<ol>
<li>定义子问题</li>
<li>写出子问题的递推关系</li>
<li>确定 DP 数组的计算顺序</li>
<li>空间优化（可选）</li>
</ol>
<h1 id="基础递推算法">基础递推算法</h1>
<p>本节总结了各类利用DP数组自底而上的算法，以子问题递推关系分类。</p>
<h2 id="子问题求和">子问题求和</h2>
<p>最简单的递推关系就是后一个子问题等于前几个子问题求和，如<a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a>、<a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a>。这两个问题大家都会，这里不再赘述，需要注意的是最小的几个子问题<strong>需要特判</strong>。</p>
<p>除了编程题以外，斐波拉契数列和泰波拉契数列是大厂笔试找规律题的常客，通常换掉头几项，但递推关系一样。</p>
<p>1，3，4，7，11，18，29，……（斐波拉契）</p>
<p>1，3，5，9，17，31，57，……（泰波拉契）</p>
<p>下面列出了几个子问题求和的典型问题。</p>
<h3 id="爬楼梯">爬楼梯</h3>
<p>【爬楼梯】这类题和斐波拉契数列解法完全相同，高阶一点的还有【最小花费爬楼梯】。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a>：假设你正在爬楼梯。需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
</blockquote>
<pre><code class="language-cpp">class Solution {
public:
    int climbStairs(int n) {
        //注意特判！！
        if (n &lt; 3){
            return n;
        }
        //只记录f(n-1)和f(n-2)两个状态
        //注意：只记录两个状态比递归时间复杂度低，是因为递归计算f(n-1)时重复计算了f(n-2)
        int ans, a = 1, b = 2;
        for (int i = 3; i &lt;= n; i++){
            ans = a + b;
            a = b;
            b = ans;
        }
	    return ans; 
    }
};
</code></pre>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a>：数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值<code>cost[i]</code>（下标从 0 开始）。每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
</blockquote>
<pre><code class="language-cpp">class Solution {
public:
    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {
       int n = cost.size();//注意：顶层是n+1
        int a = 0, b = 0;//a、b初始化为到0、1阶梯的最低花费
        for (int i = 2; i &lt;= n; i++){//顶层是n+1，所以i&lt;=n要取等
            int next = min(a + cost[i - 2], b + cost[i - 1]);//计算下一阶梯的最低花费
            a = b;
            b = next;
        }
        return b; //返回next
    }
};
</code></pre>
<h3 id="杨辉三角">杨辉三角</h3>
<p>【杨辉三角】这类题要注意两点，一是数组首尾不满足递推关系，二是可以把上层数组复制用于计算下层。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a>：给定一个非负整数 <code>numRows</code>，生成「杨辉三角」的前 <code>numRows</code>行。注意：<code>1&lt;=numRows&lt;=30</code></p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
</blockquote>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt; ans;
        for (int i=0;i&lt;numRows;i++){
            //getRow()计算杨辉三角的每一行元素，定义见【杨辉三角II】
            ans.push_back(getRow(i));
        }
        return ans;
    }
};
</code></pre>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a>：给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。注意：<code>0&lt;=rowIndex&lt;=33</code></p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
</blockquote>
<p>为了便于理解，这里把杨辉三角写成直角三角形：</p>
<p><code>row[0]</code>：1</p>
<p><code>row[1]</code>：1，1</p>
<p><code>row[2]</code>：1，2，1</p>
<p><code>row[3]</code>：1，3，3，1</p>
<p><code>row[4]</code>：1，4，6，4，1</p>
<p>……</p>
<p>注意到，<code>row[n-1]</code>到<code>row[n]</code>的步骤是：</p>
<ol>
<li><code>row[n]</code>初始化为：<code>{row[n-1],1}</code>；</li>
<li>从<code>j=n-1</code>开始一直到<code>j=1</code>，每个元素更新为<code>row[n][j]=row[n][j]+row[n][j-1]</code>。</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; getRow(int rowIndex) {
        int n = rowIndex + 1; //第k行有k+1个元素
        vector&lt;int&gt; res{ 1 }; //每行第一个元素一定是1，第0行只有一个1
        //注意vector的赋值方法：res{a,b,c,d,...}，即res={a,b,c,d,...}
        for (int i = 1; i &lt; n; i++){//从第1行开始
            res.push_back(1); //每一行最后一个元素一定是1
            for (int j = i - 1; j &gt;= 1; j--){//每一行只用改变中间元素，中间元素是上一行（i-1）相邻元素之和
                res[j] = res[j] + res[j - 1];
            }
        }
        return res;
    }
};
</code></pre>
<h2 id="子问题最值">子问题最值</h2>
<p>另一种常见递推关系是后一个子问题等于前几个子问题的最值，典型的问题是【打家劫舍】和【最大子序和】。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a>：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p>本题对状态的选择可以说是这类问题的一个通用选法，即定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[0,i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>房屋中能偷到的最高金额，注意这里选择<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>​作为<strong>右边界</strong>。</p>
<p>递推关系为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo>]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i]=\max(dp[i-2]+nums[i],dp[i-1])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>即要么偷<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo>]</mo><mo>+</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">[0,i-2]+i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，要么偷<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[0,i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，二者取最大值。</p>
<pre><code class="language-cpp">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
         //自底而上计算
        int a = 0, b = 0;
        //假设前面多了两个房子，里面金额为0，那么不影响最后结果
        for (int i : nums){
            //房屋相邻关系[a,b,i]，偷a+i和b较大的
            int next = max(b, a + i);
            a = b;
            b = next;
        }
        return b;
    }
};
</code></pre>
<h3 id="最大子序和">最大子序和</h3>
<p>根据不同问题要求，迭代过程中有时需要返回所有子问题最值，即打擂维护最值。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a>：给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>类似上一题，我们定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>为<strong>以第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>​个数结尾</strong>的连续子数组最大和，那么递推关系为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i]=\max(dp[i-1]+nums[i],nums[i])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>即要么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[0,i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>作为一个连续子数组，要么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>单独做一个连续子数组。</p>
<p>此外，对于求最大子序和，有一个通用解法：【<strong>kadane算法</strong>】。为了讲解该算法原理，同样定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>​为<strong>以第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>​​个数结尾</strong>的连续子数组最大和，写成数学表达式为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><munder><mi>max</mi><mo>⁡</mo><mi>i</mi></munder><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[j] = \max_i(nums[i]+nums[i+1]+\cdots+nums[j])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.477664em;vertical-align:-0.7276640000000001em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999983em;"><span style="top:-2.072336em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7276640000000001em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的关系可以分类讨论，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">nums[j]\geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>加上它肯定不会小于自己，此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[j]=dp[j-1]+nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>；如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">nums[j]&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>加上它会变小，因此不加它，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[j]=dp[j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。</p>
<p>综上所述​，递推关系为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i]=dp[i-1]+\max(nums[i],0)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p>
<p>上面这两种算法是等价的。</p>
<pre><code class="language-cpp">int maxSubArray(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    int pre = 0, rmax = nums[0];
    for (int i = 0; i &lt; n; i++){//f(i)表示以第i个数结尾的“连续子数组最大和”
        //i-1结尾的最大和+nums[i]和仅一个nums[i]比较大小
        pre = max(pre + nums[i], nums[i]); //f(i)=max(f(i-1)+nums[i],nums[i])
        //f(i)=nums[i]+max(f(i-1),0)是另一种写法（kadane算法），如果f(i-1)是正的，则相加必然更大，否则从i重新开始
        rmax = max(pre, rmax); //打擂维护最大和
    }
    return rmax;
}
</code></pre>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">1014. 最佳观光组合</a>：给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。一对景点（i &lt; j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。返回一对观光景点能取得的最高分。</p>
</blockquote>
<pre><code class="language-cpp">int maxScoreSightseeingPair(vector&lt;int&gt;&amp; values) {
    int n = values.size();
    //curr是以i为右边界的数组中最高景点得分
    int curr = values[1] + values[0] - 1, vmax = curr;
    for (int i = 2; i &lt; n; i++){
        //令curr是[l,i-1]，那么下一步最高分要么是[l,i]，要么是[i-1,i]
        //[l,i-1]怎么办？上一轮比过了！
        curr = max(curr + values[i] - values[i - 1] - 1, values[i] + values[i - 1] - 1);
        vmax = max(curr, vmax);
    }
    return vmax;
}
</code></pre>
<p>官方题解用了另一种思路：对于每一个j而言，<code>values[j]-j</code>是固定的，那么以j为右边界的最大得分取决于<code>values[i]+i</code>。那么只需要一次遍历，每次找到最大<code>values[i]+i</code>即可。</p>
<pre><code class="language-cpp">int maxScoreSightseeingPair(vector&lt;int&gt;&amp; values) {
    int n = values.size();
    //imax为最大values[i]+i
    int imax = values[0] + 0, vmax = 0;
    for (int j = 1; j &lt; n; j++){
        vmax = max(values[j] - j + imax, vmax);//维护最高得分（前一个维护要返回的最优解）
        imax = max(values[j] + j, imax);//维护最大imax（后一个维护j之前的子问题最值）
    }
    return vmax;
}
</code></pre>
<p>这一思路同样可以用于【买卖股票的最佳时机】（只能买卖一次）。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a>：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
</blockquote>
<pre><code class="language-cpp">int maxProfit(vector&lt;int&gt;&amp; prices) {
	int n = prices.size();
    if (n&lt;2) return 0;//注意特判，有些测试用例会给一些特殊情况
	int pmin = prices[0], rmax = 0;
	for (int i = 1; i &lt; n; i++){
		rmax = max(rmax, prices[i] - pmin);//维护利润最大值（pmin是所有以前天数价格最小值）
		pmin = min(pmin, prices[i]);//维护买入价格最小值
	}
	return rmax;
}
</code></pre>
<h2 id="二维dp数组">二维DP数组</h2>
<p>对于【不同路径】这样的题，无法仅用两三个变量维护子问题状态，需要用到二维DP数组。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a>：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://star2dust.github.io/post-images/1629012993211.png" alt="" loading="lazy"></figure>
<pre><code class="language-cpp">class Solution {
public:
    int uniquePaths(int m, int n) {
        //定义dp数组
        vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n));
        //特判，如果行或者列为1，则路径只有1条
        for (int i = 0; i &lt; m; i++){
            dp[i][0] = 1;
        }
        for (int i = 0; i &lt; n; i++){
            dp[0][i] = 1;
        }
        //动态规划
        for (int i = 1; i &lt; m; i++){
            for (int j = 1; j &lt; n; j++){
                //机器人只能向下或者向右移动一步，故需要维护两个状态，即左方和上方
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
</code></pre>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a>: 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。<br>
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
</blockquote>
<pre><code class="language-cpp">class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.length(), n = text2.length();
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
        for (int i = 1; i &lt;= m; i++) {
            char c1 = text1.at(i - 1);
            for (int j = 1; j &lt;= n; j++) {
                char c2 = text2.at(j - 1);
                if (c1 == c2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
};
</code></pre>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/uncrossed-lines/">1035. 不相交的线</a>: 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：</p>
<ul>
<li>
<p>nums1[i] == nums2[j]</p>
</li>
<li>
<p>且绘制的直线不与任何其他连线（非水平线）相交。</p>
</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
</blockquote>
<pre><code class="language-cpp">class Solution {
public:
    int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int m = nums1.size(), n = nums2.size();
        // dp[i][j]表示num1[0:i]和num2[0:j]的最大公共子序列长度（左闭右开）
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
        for (int i = 1; i &lt;= m; i++) {
            int num1 = nums1[i - 1];
            for (int j = 1; j &lt;= n; j++) {
                int num2 = nums2[j - 1];
                //如果是公共元素则加1
                if (num1 == num2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
};

</code></pre>
<h2 id="非最优子结构">非最优子结构</h2>
<p>有些问题没有最优子结构，无法通过子问题的组合得到递推关系，但是也能通过维护多个状态的思想来应用动态规划算法。通常问题是带有交替符号特性的，还要注意存temp以避免变量覆盖。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a>：给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
</blockquote>
<p>如果我们用【最大子序和】的经验，可以得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>∗</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i]=\max(dp[i-1]*nums[i],nums[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>​，但在这里是错的，为什么呢？</p>
<p>因为这里的定义并不满足「最优子结构」，当前位置的最优解未必是由前一个位置的最优解转移得到的，即乘法会变符号，最大值可能下一步变成最小值，那么需要用两个DP数组同时维护最大值和最小值，如果变号就乘最小值，未变号就乘最大值。</p>
<pre><code class="language-cpp">int maxProduct(vector&lt;int&gt;&amp; nums) {
	//pmax:以i为右边界乘积最大值，pmin:以i为右边界乘积最小值（可能是负的）
	int pmax = nums[0], pmin = nums[0], ans = nums[0];
	for (int i = 1; i &lt; nums.size(); ++i) {
		int mx = pmax, mn = pmin; //存temp避免变量覆盖
		//最大值有3种可能：1. pmax*nums[i]; 2. pmin*nums[i]; 3. nums[i]
		pmax = max(mx * nums[i], max(nums[i], mn * nums[i]));
		pmin = min(mn * nums[i], min(nums[i], mx * nums[i]));
		ans = max(pmax, ans);
	}
	return ans;
}
</code></pre>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">1567. 乘积为正数的最长子数组长度</a>：给你一个整数数组<code>nums</code> ，请你求出乘积为正数的最长子数组的长度。一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。请你返回乘积为正数的最长子数组长度。</p>
</blockquote>
<pre><code class="language-cpp">int getMaxLen(vector&lt;int&gt;&amp; nums) {
	int n = nums.size();
	//pos:以i为右边界乘积为正的最长子数组长度，neg:以i为有边界乘积为负的最长子数组长度
	int pos = (nums[0] &gt; 0), neg = (nums[0] &lt; 0); 
	//题目要求乘积为正，故lmax=pos
	int lmax = pos;
	for (int i = 1; i &lt; n; i++){
		if (nums[i]&gt;0){
			//如果nums[i]&gt;0，则不改变符号，pos自加1，neg&gt;0加1，==0不变
			pos = pos + 1;
			neg = neg &gt; 0 ? neg + 1 : 0;
		}
		else if (nums[i] &lt; 0){
			//如果nums[i]&lt;0，则改变符号，和上面以相反方式赋值
			int pos_temp = neg&gt;0 ? neg + 1 : 0;//存temp避免变量覆盖
			int neg_temp = pos + 1;
			pos = pos_temp;
			neg = neg_temp;
		}
		else{
			pos = 0, neg = 0;
		}
		lmax = max(lmax, pos);
	}
	return lmax;
}
</code></pre>
<h1 id="买卖股票多状态递推">买卖股票（多状态递推）</h1>
<p>有些复杂问题不只有一种状态，每一种状态都有相应的子问题递推关系，最后返回所有状态中的最值。</p>
<p>详见力扣平台上的股票类型的题目：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a>（只能买卖一次，该问题只需要维护一个状态，见【子问题最值】一节）</li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>（可以买卖多次，见【贪心算法】一节）</li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a>（最多买卖两次）</li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a>（最多买卖k次）</li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a>（买卖多次，卖出有一天冷冻期）</li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a>（买卖多次，每次有手续费）</li>
</ul>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>：给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<pre><code class="language-cpp">int maxProfit2(vector&lt;int&gt;&amp; prices) {
	int n = prices.size();
	if (n &lt; 2) return 0;
	int p0 = -prices[0], p1 = 0;//两种状态
    //p0：持有股票时最大利润
    //p1：不持有股票时最大利润
	for (int i = 0; i &lt; n; i++){
		int p0_temp = max(p0, p1 - prices[i]);//继续持有或买入
		int p1_temp = max(p1, p0 + prices[i]);//继续不持有或卖出
		p0 = p0_temp;
		p1 = p1_temp;
	}
	return p1;//最后持有不卖没有意义，只需返回不持有时最大利润
}
</code></pre>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a>：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
</blockquote>
<pre><code class="language-cpp">int maxProfit5(vector&lt;int&gt;&amp; prices) {
	int n = prices.size();
	if (n &lt; 2) return 0;
	int p0 = -prices[0], p1 = 0, p2 = 0;//三种状态
	// p0: 手上持有股票的最大收益
	// p1: 手上不持有股票，并且当天结束时处于冷冻期中的累计最大收益（i天卖出）
	// p2: 手上不持有股票，并且当天结束时不在冷冻期中的累计最大收益（i-1天及之前卖出）
	for (int i = 1; i &lt; n; i++){
		int p0_temp = max(p2 - prices[i], p0);//i天买入或者继续持有
		int p1_temp = p0 + prices[i];//i天卖出
		int p2_temp = max(p1, p2);//继续不持有
		p0 = p0_temp, p1 = p1_temp, p2 = p2_temp;
	}
	return max(p1, p2);//最后持有不卖没有意义，只需返回不持有时最大利润
}
</code></pre>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a>：给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
</blockquote>
<pre><code class="language-cpp">int maxProfit6(vector&lt;int&gt;&amp; prices, int fee) {
    //此题和122几乎一模一样，唯一的区别在于手续费，这里假设每次卖出时收费
	int n = prices.size();
	if (n &lt; 2) return 0;
	int p0 = -prices[0], p1 = 0;//两种状态
    //p0：持有股票的最大收益
    //p1：不持有股票的最大收益
	for (int i = 0; i &lt; n; i++){
		int p0_temp = max(p0, p1 - prices[i]);//继续持有或买入
		int p1_temp = max(p1, p0 + prices[i] - fee);//继续不持有或卖出，卖出时收手续费
		p0 = p0_temp;
		p1 = p1_temp;
	}
	return p1;//返回不持有时最大利润
}
</code></pre>
<h1 id="打家劫舍分治算法">打家劫舍（分治算法）</h1>
<p><strong>分治法</strong>的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>动态规划问题可以表示为多个子问题的组合，如果子问题同样也是动态规划问题，且解法相同，则可以用分治法。一般情况下，除非子问题很明显是已经解决过的老问题，尽量不考虑分治。</p>
<p>详见力扣平台的打家劫舍类型题目：</p>
<ul>
<li>
<p><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a>（见【子问题最值】一节）</p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a>（环形打家劫舍）</p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数</a>（打家劫舍IV）</p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></p>
</li>
</ul>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a>：你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
</blockquote>
<pre><code class="language-cpp">int rob2(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    //特判
    if (n == 1){
        return nums[0];
    }
    else if (n == 2){
        return max(nums[0], nums[1]);
    }
    //因为0和n-1不能同时偷，根据n-1偷不偷，将问题分解为[0,n-2]和[1,n-1]两个打家劫舍问题
    return max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));
}
int robRange(vector&lt;int&gt;&amp; nums, int start, int end){
    //带范围的打家劫舍问题
    int a = 0, b = 0;
    for (int i = start; i &lt;= end; i++){
        int next = max(b, a + nums[i]);
        a = b;
        b = next;
    }
    return b;
}
</code></pre>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a>：给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当<code>0 &lt;= i &lt; A.length</code> 时 <code>C[i] = A[i]</code>，且当 <code>i &gt;= 0</code> 时 <code>C[i+A.length] = C[i]</code>）此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 <code>C[i], C[i+1], ..., C[j]</code>，不存在 <code>i &lt;= k1, k2 &lt;= j</code> 其中 <code>k1 % A.length = k2 % A.length</code>）</p>
</blockquote>
<pre><code class="language-cpp">int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) {
	int dp = nums[0];      //初始化dp，以i结尾的最大子序列和
	int smax = dp;         //非环最大子序列和
	int sum = dp;          //整个数组的和
	//求最大子序列和，见53题，kadane算法
	for (int i = 1; i &lt; nums.size(); i++) {
		dp = nums[i] + max(dp, 0);
		smax = max(dp, smax);
		sum += nums[i];//附加了一个整个数组求和，故不能直接调用53
	}
	//整个数组总和是一定的，减掉[1,n-2]范围最小子序列和，剩下两头部分首尾相连，即为环最大子序列和
	int smin = 0;
	dp = nums[0]; //这里是0，后面计算1时需要该值，不代表序列从0计算
	for (int i = 1; i &lt; nums.size() - 1; i++) {
		dp = nums[i] + min(dp, 0);
		smin = min(dp, smin);
	}
	//环最大子序列和要么是非环最大子序列和，要么是整个数组的和减[1,n-2]最小序列和
	return max(sum - smin, smax);
}
</code></pre>
<p>环最大子序列和要么是非环最大子序列和，要么是整个数组的和减[1,n-2]最小序列和，如下图所示（图片来自力扣）。</p>
<ul>
<li>不同时包括0和n-1，环最大子序列和是非环最大子序列和，即53题；</li>
<li>同时包括0和n-1，环最大子序列和是整个数组的和减[1,n-2]最小序列和，因为整个数组总和是一定的，令中间[1,n-2]范围子序列和最小，再减掉，剩下两头部分首尾相连，即为环最大子序列和。</li>
</ul>
<img src="https://star2dust.github.io/post-images/1626937363129.png" style="zoom:50%;" />
<p>值得一提的是，有些问题可以经过数据结构转换变成已解决过的动态规划问题。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数</a>：给你一个整数数组 <code>nums</code>，你可以对它进行一些操作。每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 所有 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
</blockquote>
<pre><code class="language-cpp">//删除相邻元素的操作，有没有似曾相识
//其实就是相邻房屋不能偷
int deleteAndEarn(vector&lt;int&gt;&amp; nums) {
    int nmax = 0;
    for (int i : nums){
        nmax = max(nmax, i);
    }
    //求数组最大点数（房屋最大编号）
    vector&lt;int&gt; all(nmax + 1);
    for (int i : nums){
        all[i] += i; //同点数的元素点数求和（总金额）放在点数对应编号的房屋里
    }
    return rob(all);//跑一遍打家劫舍
}
</code></pre>
<h1 id="贪心算法">贪心算法</h1>
<p>前面讲了常规的子问题递推方法，下面讲<strong>贪心算法</strong>。核心思路是，在递推的同时，尽可能保证最大化目标。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a>：给定一个非负整数数组<code>nums</code>，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p>
</blockquote>
<p>在本问题中，如果能到达某个位置，那一定能到达它前面的所有位置。对于任意y，只要存在一个x，使得跳跃最大长度<code>x+nums[x]</code>大于等于y，那么y必然可以到达。这样以来，我们依次遍历数组中的每一个位置，并实时维护<strong>最远可以到达的位置</strong>。对于当前遍历到的位置x，如果它在最远可以到达的位置的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用<code>x+nums[x]</code>更新最远可以到达的位置。遍历的过程中，如果最远可以到达的位置大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。</p>
<pre><code class="language-cpp">bool canJump(vector&lt;int&gt;&amp; nums) {
	int n = nums.size(), far = 0; //找到最远能到达的点far
	for (int i = 0; i &lt;= far; i++){//如果i在最远可以到达的点范围内
		far = max(far, i + nums[i]);//每到一个位置更新最远能到达的点
		if (far &gt;= n - 1){//最远位置超过n-1即成功
			return true;
		}
	}
	return false;
}
</code></pre>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a>：给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</p>
</blockquote>
<p>在本问题中，我们「贪心」地进行正向查找，找到可到达的最远位置x，在[0,x]之间遍历维护下一步能到达的最远位置y，遍历完毕更新边界为[x,y]并将跳跃次数增加 1，重复遍历过程，直到新的右边界大n-1。</p>
<pre><code class="language-cpp">int jump(vector&lt;int&gt;&amp; nums) {
	int n = nums.size(), far = 0, end = 0, cnt = 0;
	for (int i = 0; i &lt; n - 1; i++){//遍历到n-2避免最后重复跳一次（nums[n-2]必大于0）
		if (far &gt;= i){
			far = max(far, i + nums[i]);//一跳最远距离
			if (i == end){//如果到了右边界end，更新end=far，上一次的end变成左边界）
				end = far;
				cnt++;//保证i遍历到end之前只跳一次
			}
		}
	}
	return cnt;
}
</code></pre>
<p>利用贪心算法，我们也可以给买卖股票问题提供一个新的思路。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>：给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</p>
</blockquote>
<pre><code class="language-cpp">int maxProfit2(vector&lt;int&gt;&amp; prices) {
	int n = prices.size();
	int rmax = 0;
	for (int i = 1; i &lt; n; i++){
		if (prices[i] - prices[i - 1] &gt; 0){//只要股票涨一天就加上一天收益，不涨就在前一天卖掉
			rmax += prices[i] - prices[i - 1];
		}
	}
	return rmax;
}
</code></pre>
<h1 id="背包问题">背包问题</h1>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a>：给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<p>本题中定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>为凑成金额<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>的最少硬币数量，我们注意到这个问题有一个最优的子结构性质，这是解决动态规划问题的关键。最优解可以从其子问题的最优解构造出来。如何将问题分解成子问题？假设我们知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>​，即组成金额 S<em>S</em> 最少的硬币数，最后一枚硬币的面值是 C<em>C</em>。那么由于问题的最优子结构，转移方程应为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>S</mi><mo>)</mo><mo>=</mo><mi>F</mi><mo>(</mo><mi>S</mi><mo>−</mo><mi>C</mi><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(S)=F(S-C)+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>但我们不知道最后一枚硬币的面值是多少，所以我们需要枚举每个硬币面额值，并选择其中的最小值。下列递推关系成立：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>S</mi><mo>)</mo><mo>=</mo><munder><mi>min</mi><mo>⁡</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munder><mi>F</mi><mo>(</mo><mi>S</mi><mo>−</mo><msub><mi>C</mi><mi>i</mi></msub><mo>)</mo><mo>+</mo><mn>1</mn><mspace width="1em"/><mi>s</mi><mi mathvariant="normal">.</mi><mi>t</mi><mi mathvariant="normal">.</mi><mspace width="1em"/><mi>S</mi><mo>−</mo><msub><mi>C</mi><mi>i</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(S)=\min_{i=0,\dots,n-1} F(S-C_i)+1\quad s.t.\quad S-C_i&gt;0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.613772em;vertical-align:-0.863772em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.0723360000000004em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="minner mtight">…</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.863772em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>S</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(S)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>S</mi><mo>)</mo><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(S)=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>​。</p>
<p>为了避免重复的计算，我们将每个子问题的答案存在一个DP数组中进行记忆化，如果下次还要计算这个问题的值直接从数组中取出返回即可，这样能保证每个子问题最多只被计算一次。</p>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>S</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(Sn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 是金额，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是面额数。我们一共需要计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 个状态的答案，且每个状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> 由于上面的记忆化的措施只计算了一次，而计算一个状态的答案需要枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个面额值，所以一共需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>S</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(Sn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的时间复杂度。<br>
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>，我们需要额外开一个长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 的数组来存储计算出来的答案 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-cpp">class Solution {
    vector&lt;int&gt;count;//DP数组
    int dp(vector&lt;int&gt;&amp; coins, int rem) {
        //特判
        if (rem &lt; 0) return -1;
        if (rem == 0) return 0;
        //有值则直接返回值，不重复计算
        if (count[rem - 1] != 0) return count[rem - 1];
        //枚举coin找到最小数量
        int Min = INT_MAX;
        for (int coin:coins) {
            int res = dp(coins, rem - coin);
            if (res &gt;= 0 &amp;&amp; res &lt; Min) {//先排除-1
                Min = res + 1;
            }
        }
        count[rem - 1] = Min == INT_MAX ? -1 : Min;
        return count[rem - 1];
    }
public:
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {
        if (amount &lt; 1) return 0;//amount从1~S，不考虑0
        count.resize(amount);
        return dp(coins, amount);
    }
};
</code></pre>
<p>下面我们采用自下而上的方式进行思考。仍定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 为组成金额 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>​​ 所需最少的硬币数量。则递推关系为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>=</mo><munder><mi>min</mi><mo>⁡</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munder><mi>F</mi><mo>(</mo><mi>i</mi><mo>−</mo><msub><mi>C</mi><mi>j</mi></msub><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(i)=\min_{j=0,\dots,n-1} F(i-C_j)+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.613772em;vertical-align:-0.863772em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.0723360000000004em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="minner mtight">…</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.863772em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(i)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>去掉。</p>
<pre><code class="language-cpp">class Solution {
public:
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {
        int Max = amount + 1;
        vector&lt;int&gt; dp(amount + 1, Max);//初始化为amount+1
        dp[0] = 0;
        for (int i = 1; i &lt;= amount; ++i) {
            for (int j = 0; j &lt; (int)coins.size(); ++j) {
                if (coins[j] &lt;= i) {//dp[负数]的情况去掉
                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] &gt; amount ? -1 : dp[amount];
        //dp[amount] &gt; amount说明没变化，还是初始值
    }
};
</code></pre>
<p>01背包和完全背包模板：</p>
<pre><code class="language-cpp">for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
</code></pre>
]]></content>
    </entry>
</feed>