<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>【力扣刷题】深度/广度优先搜索算法思路解析和标准模板 | star2dust</title>
<link rel="shortcut icon" href="https://star2dust.github.io/favicon.ico?v=1653562569417">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://star2dust.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="【力扣刷题】深度/广度优先搜索算法思路解析和标准模板 | star2dust - Atom Feed" href="https://star2dust.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
问题描述
深度/广度优先搜索算法

两种算法标准模板
797. 所有可能的路径（解法一）


深度优先搜索的递归回溯算法

回溯算法
797. 所有可能的路径（解法二）


Dijkstra算法

带备忘录的广度优先搜索算法
Dijkst..." />
    <meta name="keywords" content="Algorithm" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://star2dust.github.io">
  <img class="avatar" src="https://star2dust.github.io/images/avatar.png?v=1653562569417" alt="">
  </a>
  <h1 class="site-title">
    star2dust
  </h1>
  <p class="site-description">
    每天进步一点点
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://blog.csdn.net/u010038790" class="menu" target="_blank">
          博客
        </a>
      
    
      
        <a href="https://github.com/star2dust/paper-simulation" class="menu" target="_blank">
          论文复现
        </a>
      
    
      
        <a href="https://github.com/star2dust/Robotics-Toolbox" class="menu" target="_blank">
          工具箱
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/star2dust" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
        <a href="https://weibo.com/u/2473019655/" target="_blank">
          <i class="ri-weibo-line"></i>
        </a>
      
    
      
        <a href="https://www.zhihu.com/people/dong-nan-che" target="_blank">
          <i class="ri-zhihu-line"></i>
        </a>
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              【力扣刷题】深度/广度优先搜索算法思路解析和标准模板
            </h2>
            <div class="post-info">
              <span>
                2021-07-26
              </span>
              <span>
                15 min read
              </span>
              
                <a href="https://star2dust.github.io/tag/DuA8BNEBr/" class="post-tag">
                  # Algorithm
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p><ul class="markdownIt-TOC">
<li><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</a></li>
<li><a href="#%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">深度/广度优先搜索算法</a>
<ul>
<li><a href="#%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF">两种算法标准模板</a></li>
<li><a href="#797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%B3%95%E4%B8%80">797. 所有可能的路径（解法一）</a></li>
</ul>
</li>
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">深度优先搜索的递归回溯算法</a>
<ul>
<li><a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">回溯算法</a></li>
<li><a href="#797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%B3%95%E4%BA%8C">797. 所有可能的路径（解法二）</a></li>
</ul>
</li>
<li><a href="#dijkstra%E7%AE%97%E6%B3%95">Dijkstra算法</a>
<ul>
<li><a href="#%E5%B8%A6%E5%A4%87%E5%BF%98%E5%BD%95%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">带备忘录的广度优先搜索算法</a></li>
<li><a href="#dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF">Dijkstra算法模板</a></li>
<li><a href="#743-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4">743. 网络延迟时间</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="问题描述">问题描述</h1>
<p>给定一个<strong>图</strong>(graph)，已知起始点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>和目标点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>，搜索图产生一条<strong>搜索树</strong>(search tree)，那么反向查找即可找到一条从起始点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>到目标点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>​的路径。</p>
<img src="https://star2dust.github.io/post-images/1627265150549.png" style="zoom: 50%;" />
<p>问题难点在于，如何构建这个搜索树？需要思考几个问题：</p>
<ul>
<li>是否一定要构建一整个搜索树？如果不是，我们需要遍历哪些点？</li>
<li>搜索终止条件是什么？如果图是环形的怎么办？</li>
<li>如何尽快找到目标点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>？</li>
</ul>
<p>为了解决这几个问题，我们提出<strong>容器</strong>(container)的概念。如果不需要遍历所有节点，那么只将需要遍历的点放入容器中，容器初始状态放入起始点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>。搜索终止条件就很明显了，当容器为空即终止。那么图是环形的怎么办呢？我们需要定义一个备忘录，标记以访问节点和未访问节点，避免重复搜索。</p>
<h1 id="深度广度优先搜索算法">深度/广度优先搜索算法</h1>
<p>深度优先搜索算法(depth first search)和广度优先搜索算法(breadth first search)用于解决构建搜索树问题的两种算法，他们的区别在于容器的不同。</p>
<img src="https://star2dust.github.io/post-images/1627265942074.png" style="zoom: 50%;" />
<p>深度优先搜索算法的策略是：移除/扩展容器中最深的节点，即后入先出(last in first out)。</p>
<img src="https://star2dust.github.io/post-images/1627267339863.png" style="zoom: 50%;" />
<p>广度优先搜索算法的策略是：移除/扩展容器中最浅的节点，即先入先出(first in first out)。</p>
<img src="https://star2dust.github.io/post-images/1627267555658.png" style="zoom: 50%;" />
<h2 id="两种算法标准模板">两种算法标准模板</h2>
<p>广度/深度优先搜索算法标准模板：</p>
<pre><code class="language-cpp">void bfs(邻接表, 起始节点, 目标节点)/*dfs(邻接表, 起始节点, 目标节点)*/{
    定义队列/*堆栈*/;
    定义备忘录，用于记录已经访问的节点;//如果图是树结构，则不需要备忘录
    将全部起始节点加入到队列/*堆栈*/中（空路径后加该节点）;
    更新备忘录；//必须加入时更新备忘录
    while (队列不为空){
        获取当前队列(当前层级)中的节点个数；//必须在这里读队列长度，因为后面队列长度会变
        for (该层所有节点){
            复制当前节点；
            出队/*出栈*/当前节点；
            for (全部目标节点){//最关键的循环终止条件
                if (当前节点==当前目标节点){
                    存当前路径；
                    继续/返回；//只需一条路径用返回，多条用继续
                }
            }
            for (邻接节点：邻接表[当前节点]){
                if (邻接节点可行且未访问过){
                    //如果入队时不更新备忘录，此时有可能又搜到上层节点
					加入该邻接节点到队列/*堆栈*/（当前路径后加该邻接节点）；
                    更新备忘录；
                }
            }
        }
    }
    遍历完毕，返回；
}
</code></pre>
<p>由于广度优先和深度优先仅取决于容器的不同，所以上面以广度优先搜索为基础，用注释符号标注出了深度优先不同于广度优先的地方。</p>
<p>注意：该标注模版仅能保证<strong>完全遍历</strong>，但搜索的路径是否满足要求需要具体分析。</p>
<h2 id="797-所有可能的路径解法一">797. 所有可能的路径（解法一）</h2>
<p>接下来以力扣题<a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a>为例，给出广度/深度优先搜索的题解。</p>
<blockquote>
<p>给你一个有 n 个节点的 <strong>有向无环图</strong>（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）</p>
<p>二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。</p>
<p>译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。</p>
</blockquote>
<blockquote>
<p>以下实例为我手撕的面试题，可惜没当场撕出来。</p>
<p>该题指定了起始点为{0,3}，目标点为{7,8} ，输出{0,3}到{7,8}的所有路径。</p>
<p>输入实例：{{1,2},{5},{5},{4},{6},{7,8},{8},{},{}}</p>
<p>输出实例：{{0,1,5,7},{0,1,5,8},{0,2,5,7},{0,2,5,8},{3,4,6,8}}</p>
<p>0   3<br>
/ \  |<br>
1 2 4<br>
\ /  |<br>
5   6<br>
/ \ /<br>
7  8</p>
</blockquote>
<p>注意到该题为无环图，因此解法等同于<strong>层序遍历多叉森林</strong>，无需备忘录，而终止条件并非为了终止循环，而是为了记录路径。</p>
<pre><code class="language-cpp">//用于入队、入栈的节点结构
struct Node{
    int id;
    vector&lt;int&gt; path;
    
    Node(int id){
        this-&gt;id = id;
        this-&gt;path = {id};
    }
    
    Node(int id, vector&lt;int&gt; path){
        this-&gt;id = id;
        this-&gt;path = path;
        this-&gt;path.push_back(id);
    }
};
// 广度优先搜索
vector&lt;vector&lt;int&gt;&gt; bfs(vector&lt;vector&lt;int&gt;&gt; graph, vector&lt;int&gt; start, vector&lt;int&gt; goal){
    queue&lt;Node&gt; q;
    vector&lt;vector&lt;int&gt;&gt; results;
    int depth = 0;
    for (int s: start) q.push(Node(s));
    while (!q.empty()){
        int n = q.size();
        for (int i=0; i&lt;n; i++){
            Node p = q.front();
            q.pop();
            for (int g: goal){
               if (p.id==g){
                    results.push_back(p.path);
                    continue;
                } 
            }
            for (int next: graph[p.id]){
                q.push(Node(next,p.path));
            }
        }
        depth++;
    }  
    return results;
}
// 深度优先搜索
vector&lt;vector&lt;int&gt;&gt; dfs(vector&lt;vector&lt;int&gt;&gt; graph, vector&lt;int&gt; start, vector&lt;int&gt; goal){
    stack&lt;Node&gt; q;//区别1
    vector&lt;vector&lt;int&gt;&gt; results;
    int step = 0;
    for (int s: start) q.push(Node(s));
    while (!q.empty()){
        int n = q.size();
        for (int i=0; i&lt;n; i++){
            Node p = q.top();//区别2
            q.pop();
            for (int g: goal){
               if (p.id==g){
                    results.push_back(p.path);
                    continue;
                } 
            }
            for (int next: graph[p.id]){
                q.push(Node(next,p.path));
            }
        }
        step++;
    }  
    return results;
}
int main() {
    vector&lt;vector&lt;int&gt;&gt; graph = {{1,2},{5},{5},{4},{6},{7,8},{8},{},{}};
    vector&lt;int&gt; start = {0,3};
    vector&lt;int&gt; goal = {7,8};
    vector&lt;vector&lt;int&gt;&gt; paths;
    paths = bfs(graph,start,goal);
    // paths = dfs(graph,start,goal);
    return 0;
}
</code></pre>
<h1 id="深度优先搜索的递归回溯算法">深度优先搜索的递归回溯算法</h1>
<p>深度优先搜索算法也可以按照递归写，模板如下：</p>
<pre><code class="language-cpp">void dfs(当前节点){
    if (当前节点==目标节点){
        返回；//找到即返回
    }
    for (当前节点的所有下层节点){
        dfs(下层节点)；//对子树做dfs
    }
}
void main(){
    判断边界条件，是否能直接返回;
    dfs(起始节点)；
    遍历完毕，返回；    
}
</code></pre>
<p>通过上述模板，可以实现多叉森林中所有点的遍历，但是会出现重复遍历的现象。相当于搜的过程中发现此路不通，于是走了回头路。</p>
<p>那么问题来了，如果需要存路径，则必须删除这些回头路，怎么办？于是有了下面的回溯算法。</p>
<h2 id="回溯算法">回溯算法</h2>
<p><strong>回溯算法</strong>(back tracking)也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。</p>
<p>回溯算法的模板与上面深度优先搜索算法模板几乎完全一致，区别在于递归函数的前后分别有节点处理和撤销处理的两个操作。</p>
<p>回溯算法标准模板：</p>
<pre><code class="language-cpp">void backTracking(当前节点){
    if (当前节点==目标节点){
        存当前路径；
        返回；//找到即返回
    }
    for (当前节点的所有下层节点){
        当前节点加入路径；//节点处理
        backTracking(下层节点)；//对子树做bt
        路径中撤销当前节点；//撤销处理
    }
}
void main(){
    判断边界条件，是否能直接返回;
    backTracking(起始节点)；
    遍历完毕，返回；    
}
</code></pre>
<p>回溯算法中，<strong>for循环可以理解是横向遍历，backTracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了。</p>
<h2 id="797-所有可能的路径解法二">797. 所有可能的路径（解法二）</h2>
<p>这里用深度优先递归回溯方法解决力扣题<a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a>。</p>
<pre><code class="language-cpp">void dfsbt(vector&lt;vector&lt;int&gt;&gt;&amp; paths, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt; graph, int start, int goal){
    if (start==goal){
        paths.push_back(path);
        return;
    }
    for (int next: graph[start]){
        path.push_back(next);
        dfsbt(paths,path,graph,next,goal);
        path.pop_back();//撤销处理
    }
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; graph = {{1,2},{5},{5},{4},{6},{7,8},{8},{},{}};
    vector&lt;int&gt; start = {0,3};
    vector&lt;int&gt; goal = {7,8};
    vector&lt;vector&lt;int&gt;&gt; paths;
    // 与bfs每一个节点复制并维持一条路径不同，dfs有几条可行路径就维持几条
    for (int s: start){
        for (int g: goal){
            vector&lt;int&gt; path = {s};
            dfsbt(paths,path,graph,s,g);
        }
    }
    return 0;
}
</code></pre>
<h1 id="dijkstra算法">Dijkstra算法</h1>
<p>前面考虑的是<strong>有向无环无权图</strong>，bfs搜索中不会出现重复遍历，变量<code>depth</code>直接记录了路径的长度。</p>
<p>但是对于<strong>有向有环加权图</strong>，输出所有路径是不可能的，因为环的存在，每个节点能够重复遍历，所以路径有无数条。</p>
<p>为了解决环的问题，必须在bfs中引入<strong>备忘录</strong>，可以套用前面的模板，把bfs算法扩展到有向有环图上。</p>
<h2 id="带备忘录的广度优先搜索算法">带备忘录的广度优先搜索算法</h2>
<p>还是以力扣题<a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a>为例，结合前面的模板，给出以下题解。</p>
<pre><code class="language-cpp">// 带备忘录的广度优先搜索
vector&lt;vector&lt;int&gt;&gt; bfsv(vector&lt;vector&lt;int&gt;&gt; graph, vector&lt;int&gt; start, vector&lt;int&gt; goal){
    queue&lt;Node&gt; q;
    vector&lt;vector&lt;int&gt;&gt; results;
    vector&lt;int&gt; visited(graph.size());//备忘录
    int depth = 0;
    for (int s: start) {
        q.push(Node(s));
        visited[s] = 1;//入队加备忘
    }
    while (!q.empty()){
        int n = q.size();
        cout&lt;&lt;depth&lt;&lt;&quot; - &quot;;
        for (int i=0; i&lt;n; i++){
            Node p = q.front();
            q.pop();
            cout&lt;&lt;p.id&lt;&lt;&quot; &quot;;
            for (int g: goal){
               if (p.id==g){
                    results.push_back(p.path);
                    continue;
                } 
            }
            for (int next: graph[p.id]){
                if (!visited[next]){
                    q.push(Node(next,p.path));
                    visited[next] = 1;//入队加备忘
                }                
            }
        }
        depth++;
        cout&lt;&lt;endl;
    }  
    return results;
}
int main() {
    // [4,2,5,6,4]、[4,6,4]形成环
    vector&lt;vector&lt;int&gt;&gt; graph = {{1,2},{5},{5},{4},{2,6},{6,7,8},{4,8},{},{}};
    vector&lt;int&gt; start = {0,3};
    vector&lt;int&gt; goal = {7,8};
    cout&lt;&lt;&quot;算法的遍历顺序：&quot;&lt;&lt;endl;
    vector&lt;vector&lt;int&gt;&gt; paths;
    paths = bfsv(graph,start,goal);
    cout&lt;&lt;&quot;输出的路径：&quot;&lt;&lt;endl;
    for (auto p: paths) {
        for (int n: p) cout&lt;&lt;n&lt;&lt;&quot; &quot;; 
        cout&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<p>得到的输出如下：</p>
<pre><code class="language-shell">算法的遍历顺序：
0 - 0 3 
1 - 1 2 4 
2 - 5 6 
3 - 7 8 
输出的路径：
0 1 5 7 
0 1 5 8 
</code></pre>
<p>可以看出，对于有环图，在原有bfs算法引入备忘录可以保证将所有节点不重复的全部遍历一遍。</p>
<p>但是，由于备忘录的存在，节点无法重复遍历，输出的路径变少了。</p>
<h2 id="dijkstra算法模板">Dijkstra算法模板</h2>
<p>针对有向有环加权图，考虑边的权值，Dijkstra算法解决两点之间最小权值和的路径，即距离最短路径。</p>
<p>Dijkstra算法标准模板：</p>
<pre><code class="language-cpp">数组 dijkstra(邻接表, 起始节点, 目标节点){
    定义dp数组，记录起始节点到所有节点的距离，初始化为正无穷；
    dp[起始节点]=0；
    定义优先队列，按照距离由小到大排序;
    将[起始节点,起始节点距离(0)]加入到优先队列中;
    while (优先队列不为空){
        [当前节点,当前节点距离]=优先队列前端节点；
        出队优先队列前端节点；
        if (当前节点==目标节点){//循环终止条件（可选）
            返回当前节点距离；
        }
        if (当前节点距离&gt;dp[当前节点]){//循环继续条件
             继续；
        }
        for (当前节点的所有邻居节点){
            邻居节点经过当前节点到初始节点的距离=dp[当前节点]+当前节点与邻居节点之间的边权值；
            if (dp[邻居节点]&gt;邻居节点经过当前节点到初始节点的距离){
                //更新dp数组
                dp[邻居节点]=邻居节点经过当前节点到初始节点的距离;
                将[邻居节点，dp[邻居节点]]加入到优先队列中；
            }
        }
    }
    遍历完毕，返回dp数组；
}
</code></pre>
<h2 id="743-网络延迟时间">743. 网络延迟时间</h2>
<p>接下来以力扣题[<a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a>为例，给出Dijkstra算法的题解。</p>
<blockquote>
<p>有 n 个网络节点，标记为 1 到 n。</p>
<p>给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。</p>
<p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。</p>
</blockquote>
<pre><code class="language-cpp">int networkDelayTime(vector&lt;vector&lt;int&gt;&gt; &amp;times, int n, int k) {
    const int inf = INT_MAX / 2;
    //建图，得到邻接表
    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);
    for (auto &amp;t : times) {
        int x = t[0] - 1, y = t[1] - 1;//-1是因为编号起始于1
        graph[x].emplace_back(t[2],y);//第一个是权值，第二个是邻居节点
    }
    // 记录最短路径的权重，你可以理解为 dp table
    vector&lt;int&gt; dist(n, inf);
    // base case，start 到 start 的最短距离就是 0
    dist[k - 1] = 0;
    // 优先级队列，distFromStart 较小的排在前面
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; q;
    // 从起点 start 开始进行 BFS
    q.emplace(0, k - 1);
    while (!q.empty()) {
        auto p = q.top();
        q.pop();
        int time = p.first, x = p.second;
        if (dist[x] &lt; time) {
            // 已经有一条更短的路径到达 curNode 节点了
            continue;
        }
        // 将 curNode 的相邻节点装入队列
        for (auto &amp;edge : graph[x]) {
            // 看看从 curNode 达到 nextNode 的距离是否会更短
            int y = edge.second, d = dist[x] + edge.first;
            if (d &lt; dist[y]) {
                // 更新 dp table
                dist[y] = d;
                // 将这个节点以及距离放入队列
                q.emplace(d, y);
            }
        }
    }
    // max_element返回地址指针
    int ans = *max_element(dist.begin(), dist.end());
    return ans == inf ? -1 : ans;
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</a></li>
<li><a href="#%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">深度/广度优先搜索算法</a>
<ul>
<li><a href="#%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF">两种算法标准模板</a></li>
<li><a href="#797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%B3%95%E4%B8%80">797. 所有可能的路径（解法一）</a></li>
</ul>
</li>
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">深度优先搜索的递归回溯算法</a>
<ul>
<li><a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">回溯算法</a></li>
<li><a href="#797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%B3%95%E4%BA%8C">797. 所有可能的路径（解法二）</a></li>
</ul>
</li>
<li><a href="#dijkstra%E7%AE%97%E6%B3%95">Dijkstra算法</a>
<ul>
<li><a href="#%E5%B8%A6%E5%A4%87%E5%BF%98%E5%BD%95%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">带备忘录的广度优先搜索算法</a></li>
<li><a href="#dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF">Dijkstra算法模板</a></li>
<li><a href="#743-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4">743. 网络延迟时间</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://star2dust.github.io/post/leecode-dynamic-programming/">
              <h3 class="post-title">
                【力扣刷题】动态规划问题的思考与总结
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '5f35b48460c7b593fee6',
    clientSecret: '19f3646e71158e91e93151d54f5d1a19b53ce961',
    repo: 'star2dust.github.io',
    owner: 'star2dust',
    admin: ['star2dust'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Copyright &copy;<span>star2dust</span>
  <a class="rss" href="https://star2dust.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
