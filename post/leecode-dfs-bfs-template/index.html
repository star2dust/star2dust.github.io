<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>【力扣刷题】深度/广度优先搜索算法思路解析和标准模板 | star2dust</title>

<link rel="shortcut icon" href="https://star2dust.github.io/favicon.ico?v=1636882769918">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://star2dust.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>

<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            star2dust
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://blog.csdn.net/u010038790" class="menu gt-a-link" target="_blank">
                            CSDN博客
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://github.com/star2dust/paper-simulation" class="menu gt-a-link" target="_blank">
                            论文复现
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://github.com/star2dust/Robotics-Toolbox" class="menu gt-a-link" target="_blank">
                            机器人控制规划库
                        </a>
                    
                </div>
            
        </div>
    </div>
</nav>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    【力扣刷题】深度/广度优先搜索算法思路解析和标准模板
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-07-26 ·
                    </time>
                    
                        <a href="https://star2dust.github.io/tag/DuA8BNEBr/" class="post-tags">
                            # Algorithm
                        </a>
                    
                </div>
                <div class="post-content">
                    <p><ul class="markdownIt-TOC">
<li><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</a></li>
<li><a href="#%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">深度/广度优先搜索算法</a>
<ul>
<li><a href="#%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF">两种算法标准模板</a></li>
<li><a href="#797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%B3%95%E4%B8%80">797. 所有可能的路径（解法一）</a></li>
</ul>
</li>
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">深度优先搜索的递归回溯算法</a>
<ul>
<li><a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">回溯算法</a></li>
<li><a href="#797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%B3%95%E4%BA%8C">797. 所有可能的路径（解法二）</a></li>
</ul>
</li>
<li><a href="#dijkstra%E7%AE%97%E6%B3%95">Dijkstra算法</a>
<ul>
<li><a href="#%E5%B8%A6%E5%A4%87%E5%BF%98%E5%BD%95%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">带备忘录的广度优先搜索算法</a></li>
<li><a href="#dijkstra%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF">Dijkstra算法模板</a></li>
<li><a href="#743-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4">743. 网络延迟时间</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="问题描述">问题描述</h1>
<p>给定一个<strong>图</strong>(graph)，已知起始点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>和目标点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>，搜索图产生一条<strong>搜索树</strong>(search tree)，那么反向查找即可找到一条从起始点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>到目标点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>​的路径。</p>
<img src="https://star2dust.github.io/post-images/1627265150549.png" style="zoom: 50%;" />
<p>问题难点在于，如何构建这个搜索树？需要思考几个问题：</p>
<ul>
<li>是否一定要构建一整个搜索树？如果不是，我们需要遍历哪些点？</li>
<li>搜索终止条件是什么？如果图是环形的怎么办？</li>
<li>如何尽快找到目标点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>？</li>
</ul>
<p>为了解决这几个问题，我们提出<strong>容器</strong>(container)的概念。如果不需要遍历所有节点，那么只将需要遍历的点放入容器中，容器初始状态放入起始点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>。搜索终止条件就很明显了，当容器为空即终止。那么图是环形的怎么办呢？我们需要定义一个备忘录，标记以访问节点和未访问节点，避免重复搜索。</p>
<h1 id="深度广度优先搜索算法">深度/广度优先搜索算法</h1>
<p>深度优先搜索算法(depth first search)和广度优先搜索算法(breadth first search)用于解决构建搜索树问题的两种算法，他们的区别在于容器的不同。</p>
<img src="https://star2dust.github.io/post-images/1627265942074.png" style="zoom: 50%;" />
<p>深度优先搜索算法的策略是：移除/扩展容器中最深的节点，即后入先出(last in first out)。</p>
<img src="https://star2dust.github.io/post-images/1627267339863.png" style="zoom: 50%;" />
<p>广度优先搜索算法的策略是：移除/扩展容器中最浅的节点，即先入先出(first in first out)。</p>
<img src="https://star2dust.github.io/post-images/1627267555658.png" style="zoom: 50%;" />
<h2 id="两种算法标准模板">两种算法标准模板</h2>
<p>广度/深度优先搜索算法标准模板：</p>
<pre><code class="language-cpp">void bfs(邻接表, 起始节点, 目标节点)/*dfs(邻接表, 起始节点, 目标节点)*/{
    定义队列/*堆栈*/;
    定义备忘录，用于记录已经访问的节点;//如果图是树结构，则不需要备忘录
    将全部起始节点加入到队列/*堆栈*/中（空路径后加该节点）;
    更新备忘录；//必须加入时更新备忘录
    while (队列不为空){
        获取当前队列(当前层级)中的节点个数；//必须在这里读队列长度，因为后面队列长度会变
        for (该层所有节点){
            复制当前节点；
            出队/*出栈*/当前节点；
            for (全部目标节点){//最关键的循环终止条件
                if (当前节点==当前目标节点){
                    存当前路径；
                    继续/返回；//只需一条路径用返回，多条用继续
                }
            }
            for (邻接节点：邻接表[当前节点]){
                if (邻接节点可行且未访问过){
                    //如果入队时不更新备忘录，此时有可能又搜到上层节点
					加入该邻接节点到队列/*堆栈*/（当前路径后加该邻接节点）；
                    更新备忘录；
                }
            }
        }
    }
    遍历完毕，返回；
}
</code></pre>
<p>由于广度优先和深度优先仅取决于容器的不同，所以上面以广度优先搜索为基础，用注释符号标注出了深度优先不同于广度优先的地方。</p>
<p>注意：该标注模版仅能保证<strong>完全遍历</strong>，但搜索的路径是否满足要求需要具体分析。</p>
<h2 id="797-所有可能的路径解法一">797. 所有可能的路径（解法一）</h2>
<p>接下来以力扣题<a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a>为例，给出广度/深度优先搜索的题解。</p>
<blockquote>
<p>给你一个有 n 个节点的 <strong>有向无环图</strong>（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）</p>
<p>二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。</p>
<p>译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。</p>
</blockquote>
<blockquote>
<p>以下实例为我手撕的面试题，可惜没当场撕出来。</p>
<p>该题指定了起始点为{0,3}，目标点为{7,8} ，输出{0,3}到{7,8}的所有路径。</p>
<p>输入实例：{{1,2},{5},{5},{4},{6},{7,8},{8},{},{}}</p>
<p>输出实例：{{0,1,5,7},{0,1,5,8},{0,2,5,7},{0,2,5,8},{3,4,6,8}}</p>
<p>0   3<br>
/ \  |<br>
1 2 4<br>
\ /  |<br>
5   6<br>
/ \ /<br>
7  8</p>
</blockquote>
<p>注意到该题为无环图，因此解法等同于<strong>层序遍历多叉森林</strong>，无需备忘录，而终止条件并非为了终止循环，而是为了记录路径。</p>
<pre><code class="language-cpp">//用于入队、入栈的节点结构
struct Node{
    int id;
    vector&lt;int&gt; path;
    
    Node(int id){
        this-&gt;id = id;
        this-&gt;path = {id};
    }
    
    Node(int id, vector&lt;int&gt; path){
        this-&gt;id = id;
        this-&gt;path = path;
        this-&gt;path.push_back(id);
    }
};
// 广度优先搜索
vector&lt;vector&lt;int&gt;&gt; bfs(vector&lt;vector&lt;int&gt;&gt; graph, vector&lt;int&gt; start, vector&lt;int&gt; goal){
    queue&lt;Node&gt; q;
    vector&lt;vector&lt;int&gt;&gt; results;
    int depth = 0;
    for (int s: start) q.push(Node(s));
    while (!q.empty()){
        int n = q.size();
        for (int i=0; i&lt;n; i++){
            Node p = q.front();
            q.pop();
            for (int g: goal){
               if (p.id==g){
                    results.push_back(p.path);
                    continue;
                } 
            }
            for (int next: graph[p.id]){
                q.push(Node(next,p.path));
            }
        }
        depth++;
    }  
    return results;
}
// 深度优先搜索
vector&lt;vector&lt;int&gt;&gt; dfs(vector&lt;vector&lt;int&gt;&gt; graph, vector&lt;int&gt; start, vector&lt;int&gt; goal){
    stack&lt;Node&gt; q;//区别1
    vector&lt;vector&lt;int&gt;&gt; results;
    int step = 0;
    for (int s: start) q.push(Node(s));
    while (!q.empty()){
        int n = q.size();
        for (int i=0; i&lt;n; i++){
            Node p = q.top();//区别2
            q.pop();
            for (int g: goal){
               if (p.id==g){
                    results.push_back(p.path);
                    continue;
                } 
            }
            for (int next: graph[p.id]){
                q.push(Node(next,p.path));
            }
        }
        step++;
    }  
    return results;
}
int main() {
    vector&lt;vector&lt;int&gt;&gt; graph = {{1,2},{5},{5},{4},{6},{7,8},{8},{},{}};
    vector&lt;int&gt; start = {0,3};
    vector&lt;int&gt; goal = {7,8};
    vector&lt;vector&lt;int&gt;&gt; paths;
    paths = bfs(graph,start,goal);
    // paths = dfs(graph,start,goal);
    return 0;
}
</code></pre>
<h1 id="深度优先搜索的递归回溯算法">深度优先搜索的递归回溯算法</h1>
<p>深度优先搜索算法也可以按照递归写，模板如下：</p>
<pre><code class="language-cpp">void dfs(当前节点){
    if (当前节点==目标节点){
        返回；//找到即返回
    }
    for (当前节点的所有下层节点){
        dfs(下层节点)；//对子树做dfs
    }
}
void main(){
    判断边界条件，是否能直接返回;
    dfs(起始节点)；
    遍历完毕，返回；    
}
</code></pre>
<p>通过上述模板，可以实现多叉森林中所有点的遍历，但是会出现重复遍历的现象。相当于搜的过程中发现此路不通，于是走了回头路。</p>
<p>那么问题来了，如果需要存路径，则必须删除这些回头路，怎么办？于是有了下面的回溯算法。</p>
<h2 id="回溯算法">回溯算法</h2>
<p><strong>回溯算法</strong>(back tracking)也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。</p>
<p>回溯算法的模板与上面深度优先搜索算法模板几乎完全一致，区别在于递归函数的前后分别有节点处理和撤销处理的两个操作。</p>
<p>回溯算法标准模板：</p>
<pre><code class="language-cpp">void backTracking(当前节点){
    if (当前节点==目标节点){
        存当前路径；
        返回；//找到即返回
    }
    for (当前节点的所有下层节点){
        当前节点加入路径；//节点处理
        backTracking(下层节点)；//对子树做bt
        路径中撤销当前节点；//撤销处理
    }
}
void main(){
    判断边界条件，是否能直接返回;
    backTracking(起始节点)；
    遍历完毕，返回；    
}
</code></pre>
<p>回溯算法中，<strong>for循环可以理解是横向遍历，backTracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了。</p>
<h2 id="797-所有可能的路径解法二">797. 所有可能的路径（解法二）</h2>
<p>这里用深度优先递归回溯方法解决力扣题<a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a>。</p>
<pre><code class="language-cpp">void dfsbt(vector&lt;vector&lt;int&gt;&gt;&amp; paths, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt; graph, int start, int goal){
    if (start==goal){
        paths.push_back(path);
        return;
    }
    for (int next: graph[start]){
        path.push_back(next);
        dfsbt(paths,path,graph,next,goal);
        path.pop_back();//撤销处理
    }
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; graph = {{1,2},{5},{5},{4},{6},{7,8},{8},{},{}};
    vector&lt;int&gt; start = {0,3};
    vector&lt;int&gt; goal = {7,8};
    vector&lt;vector&lt;int&gt;&gt; paths;
    // 与bfs每一个节点复制并维持一条路径不同，dfs有几条可行路径就维持几条
    for (int s: start){
        for (int g: goal){
            vector&lt;int&gt; path = {s};
            dfsbt(paths,path,graph,s,g);
        }
    }
    return 0;
}
</code></pre>
<h1 id="dijkstra算法">Dijkstra算法</h1>
<p>前面考虑的是<strong>有向无环无权图</strong>，bfs搜索中不会出现重复遍历，变量<code>depth</code>直接记录了路径的长度。</p>
<p>但是对于<strong>有向有环加权图</strong>，输出所有路径是不可能的，因为环的存在，每个节点能够重复遍历，所以路径有无数条。</p>
<p>为了解决环的问题，必须在bfs中引入<strong>备忘录</strong>，可以套用前面的模板，把bfs算法扩展到有向有环图上。</p>
<h2 id="带备忘录的广度优先搜索算法">带备忘录的广度优先搜索算法</h2>
<p>还是以力扣题<a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a>为例，结合前面的模板，给出以下题解。</p>
<pre><code class="language-cpp">// 带备忘录的广度优先搜索
vector&lt;vector&lt;int&gt;&gt; bfsv(vector&lt;vector&lt;int&gt;&gt; graph, vector&lt;int&gt; start, vector&lt;int&gt; goal){
    queue&lt;Node&gt; q;
    vector&lt;vector&lt;int&gt;&gt; results;
    vector&lt;int&gt; visited(graph.size());//备忘录
    int depth = 0;
    for (int s: start) {
        q.push(Node(s));
        visited[s] = 1;//入队加备忘
    }
    while (!q.empty()){
        int n = q.size();
        cout&lt;&lt;depth&lt;&lt;&quot; - &quot;;
        for (int i=0; i&lt;n; i++){
            Node p = q.front();
            q.pop();
            cout&lt;&lt;p.id&lt;&lt;&quot; &quot;;
            for (int g: goal){
               if (p.id==g){
                    results.push_back(p.path);
                    continue;
                } 
            }
            for (int next: graph[p.id]){
                if (!visited[next]){
                    q.push(Node(next,p.path));
                    visited[next] = 1;//入队加备忘
                }                
            }
        }
        depth++;
        cout&lt;&lt;endl;
    }  
    return results;
}
int main() {
    // [4,2,5,6,4]、[4,6,4]形成环
    vector&lt;vector&lt;int&gt;&gt; graph = {{1,2},{5},{5},{4},{2,6},{6,7,8},{4,8},{},{}};
    vector&lt;int&gt; start = {0,3};
    vector&lt;int&gt; goal = {7,8};
    cout&lt;&lt;&quot;算法的遍历顺序：&quot;&lt;&lt;endl;
    vector&lt;vector&lt;int&gt;&gt; paths;
    paths = bfsv(graph,start,goal);
    cout&lt;&lt;&quot;输出的路径：&quot;&lt;&lt;endl;
    for (auto p: paths) {
        for (int n: p) cout&lt;&lt;n&lt;&lt;&quot; &quot;; 
        cout&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<p>得到的输出如下：</p>
<pre><code class="language-shell">算法的遍历顺序：
0 - 0 3 
1 - 1 2 4 
2 - 5 6 
3 - 7 8 
输出的路径：
0 1 5 7 
0 1 5 8 
</code></pre>
<p>可以看出，对于有环图，在原有bfs算法引入备忘录可以保证将所有节点不重复的全部遍历一遍。</p>
<p>但是，由于备忘录的存在，节点无法重复遍历，输出的路径变少了。</p>
<h2 id="dijkstra算法模板">Dijkstra算法模板</h2>
<p>针对有向有环加权图，考虑边的权值，Dijkstra算法解决两点之间最小权值和的路径，即距离最短路径。</p>
<p>Dijkstra算法标准模板：</p>
<pre><code class="language-cpp">数组 dijkstra(邻接表, 起始节点, 目标节点){
    定义dp数组，记录起始节点到所有节点的距离，初始化为正无穷；
    dp[起始节点]=0；
    定义优先队列，按照距离由小到大排序;
    将[起始节点,起始节点距离(0)]加入到优先队列中;
    while (优先队列不为空){
        [当前节点,当前节点距离]=优先队列前端节点；
        出队优先队列前端节点；
        if (当前节点==目标节点){//循环终止条件（可选）
            返回当前节点距离；
        }
        if (当前节点距离&gt;dp[当前节点]){//循环继续条件
             继续；
        }
        for (当前节点的所有邻居节点){
            邻居节点经过当前节点到初始节点的距离=dp[当前节点]+当前节点与邻居节点之间的边权值；
            if (dp[邻居节点]&gt;邻居节点经过当前节点到初始节点的距离){
                //更新dp数组
                dp[邻居节点]=邻居节点经过当前节点到初始节点的距离;
                将[邻居节点，dp[邻居节点]]加入到优先队列中；
            }
        }
    }
    遍历完毕，返回dp数组；
}
</code></pre>
<h2 id="743-网络延迟时间">743. 网络延迟时间</h2>
<p>接下来以力扣题[<a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a>为例，给出Dijkstra算法的题解。</p>
<blockquote>
<p>有 n 个网络节点，标记为 1 到 n。</p>
<p>给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。</p>
<p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。</p>
</blockquote>
<pre><code class="language-cpp">int networkDelayTime(vector&lt;vector&lt;int&gt;&gt; &amp;times, int n, int k) {
    const int inf = INT_MAX / 2;
    //建图，得到邻接表
    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);
    for (auto &amp;t : times) {
        int x = t[0] - 1, y = t[1] - 1;//-1是因为编号起始于1
        graph[x].emplace_back(t[2],y);//第一个是权值，第二个是邻居节点
    }
    // 记录最短路径的权重，你可以理解为 dp table
    vector&lt;int&gt; dist(n, inf);
    // base case，start 到 start 的最短距离就是 0
    dist[k - 1] = 0;
    // 优先级队列，distFromStart 较小的排在前面
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; q;
    // 从起点 start 开始进行 BFS
    q.emplace(0, k - 1);
    while (!q.empty()) {
        auto p = q.top();
        q.pop();
        int time = p.first, x = p.second;
        if (dist[x] &lt; time) {
            // 已经有一条更短的路径到达 curNode 节点了
            continue;
        }
        // 将 curNode 的相邻节点装入队列
        for (auto &amp;edge : graph[x]) {
            // 看看从 curNode 达到 nextNode 的距离是否会更短
            int y = edge.second, d = dist[x] + edge.first;
            if (d &lt; dist[y]) {
                // 更新 dp table
                dist[y] = d;
                // 将这个节点以及距离放入队列
                q.emplace(d, y);
            }
        }
    }
    // max_element返回地址指针
    int ans = *max_element(dist.begin(), dist.end());
    return ans == inf ? -1 : ans;
}
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://star2dust.github.io/post/leecode-dynamic-programming/" class="post-title gt-a-link">
                    【力扣刷题】动态规划问题的思考与总结
                </a>
            </div>
        

        

        
            
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
<script>
    // md5.min.js
    !function(n){
        "use strict";
        function d(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}
        function f(n,t,r,e,o,u){return d((c=d(d(t,n),d(e,u)))<<(f=o)|c>>>32-f,r);var c,f}
        function l(n,t,r,e,o,u,c){return f(t&r|~t&e,n,t,o,u,c)}
        function v(n,t,r,e,o,u,c){return f(t&e|r&~e,n,t,o,u,c)}
        function g(n,t,r,e,o,u,c){return f(t^r^e,n,t,o,u,c)}
        function m(n,t,r,e,o,u,c){return f(r^(t|~e),n,t,o,u,c)}
        function i(n,t){var r,e,o,u,c;n[t>>5]|=128<<t%32,n[14+(t+64>>>9<<4)]=t;var f=1732584193,i=-271733879,a=-1732584194,h=271733878;for(r=0;r<n.length;r+=16)f=l(e=f,o=i,u=a,c=h,n[r],7,-680876936),h=l(h,f,i,a,n[r+1],12,-389564586),a=l(a,h,f,i,n[r+2],17,606105819),i=l(i,a,h,f,n[r+3],22,-1044525330),f=l(f,i,a,h,n[r+4],7,-176418897),h=l(h,f,i,a,n[r+5],12,1200080426),a=l(a,h,f,i,n[r+6],17,-1473231341),i=l(i,a,h,f,n[r+7],22,-45705983),f=l(f,i,a,h,n[r+8],7,1770035416),h=l(h,f,i,a,n[r+9],12,-1958414417),a=l(a,h,f,i,n[r+10],17,-42063),i=l(i,a,h,f,n[r+11],22,-1990404162),f=l(f,i,a,h,n[r+12],7,1804603682),h=l(h,f,i,a,n[r+13],12,-40341101),a=l(a,h,f,i,n[r+14],17,-1502002290),f=v(f,i=l(i,a,h,f,n[r+15],22,1236535329),a,h,n[r+1],5,-165796510),h=v(h,f,i,a,n[r+6],9,-1069501632),a=v(a,h,f,i,n[r+11],14,643717713),i=v(i,a,h,f,n[r],20,-373897302),f=v(f,i,a,h,n[r+5],5,-701558691),h=v(h,f,i,a,n[r+10],9,38016083),a=v(a,h,f,i,n[r+15],14,-660478335),i=v(i,a,h,f,n[r+4],20,-405537848),f=v(f,i,a,h,n[r+9],5,568446438),h=v(h,f,i,a,n[r+14],9,-1019803690),a=v(a,h,f,i,n[r+3],14,-187363961),i=v(i,a,h,f,n[r+8],20,1163531501),f=v(f,i,a,h,n[r+13],5,-1444681467),h=v(h,f,i,a,n[r+2],9,-51403784),a=v(a,h,f,i,n[r+7],14,1735328473),f=g(f,i=v(i,a,h,f,n[r+12],20,-1926607734),a,h,n[r+5],4,-378558),h=g(h,f,i,a,n[r+8],11,-2022574463),a=g(a,h,f,i,n[r+11],16,1839030562),i=g(i,a,h,f,n[r+14],23,-35309556),f=g(f,i,a,h,n[r+1],4,-1530992060),h=g(h,f,i,a,n[r+4],11,1272893353),a=g(a,h,f,i,n[r+7],16,-155497632),i=g(i,a,h,f,n[r+10],23,-1094730640),f=g(f,i,a,h,n[r+13],4,681279174),h=g(h,f,i,a,n[r],11,-358537222),a=g(a,h,f,i,n[r+3],16,-722521979),i=g(i,a,h,f,n[r+6],23,76029189),f=g(f,i,a,h,n[r+9],4,-640364487),h=g(h,f,i,a,n[r+12],11,-421815835),a=g(a,h,f,i,n[r+15],16,530742520),f=m(f,i=g(i,a,h,f,n[r+2],23,-995338651),a,h,n[r],6,-198630844),h=m(h,f,i,a,n[r+7],10,1126891415),a=m(a,h,f,i,n[r+14],15,-1416354905),i=m(i,a,h,f,n[r+5],21,-57434055),f=m(f,i,a,h,n[r+12],6,1700485571),h=m(h,f,i,a,n[r+3],10,-1894986606),a=m(a,h,f,i,n[r+10],15,-1051523),i=m(i,a,h,f,n[r+1],21,-2054922799),f=m(f,i,a,h,n[r+8],6,1873313359),h=m(h,f,i,a,n[r+15],10,-30611744),a=m(a,h,f,i,n[r+6],15,-1560198380),i=m(i,a,h,f,n[r+13],21,1309151649),f=m(f,i,a,h,n[r+4],6,-145523070),h=m(h,f,i,a,n[r+11],10,-1120210379),a=m(a,h,f,i,n[r+2],15,718787259),i=m(i,a,h,f,n[r+9],21,-343485551),f=d(f,e),i=d(i,o),a=d(a,u),h=d(h,c);return[f,i,a,h]}
        function a(n){var t,r="",e=32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t>>5]>>>t%32&255);return r}
        function h(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t<e;t+=8)r[t>>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}
        function e(n){var t,r,e="0123456789abcdef",o="";for(r=0;r<n.length;r+=1)t=n.charCodeAt(r),o+=e.charAt(t>>>4&15)+e.charAt(15&t);return o}
        function r(n){return unescape(encodeURIComponent(n))}
        function o(n){return a(i(h(t=r(n)),8*t.length));var t}
        function u(n,t){return function(n,t){var r,e,o=h(n),u=[],c=[];for(u[15]=c[15]=void 0,16<o.length&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(h(t)),512+8*t.length),a(i(c.concat(e),640))}(r(n),r(t))}
        function t(n,t,r){return t?r?u(t,n):e(u(t,n)):r?o(n):e(o(n))}
        "function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:n.md5=t;
    }(this);
</script>


<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '5f35b48460c7b593fee6',
    clientSecret: '19f3646e71158e91e93151d54f5d1a19b53ce961',
    repo: 'star2dust.github.io',
    owner: 'star2dust',
    admin: ['star2dust'],
    id: md5(location.pathname),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false       // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

            

            
        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">每天进步一点点</div>
    <div class="social-container">
        
            
                <a href="https://github.com/star2dust" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
                <a href="https://weibo.com/u/2473019655" target="_blank">
                    <i class="fab fa-weibo gt-c-content-color-first"></i>
                </a>
            
        
            
                <a href="https://www.zhihu.com/people/dong-nan-che" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Copyright &copy;<span>star2dust</span>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://star2dust.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
    hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
