<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>【力扣刷题】双指针和滑动窗口 | star2dust</title>
<link rel="shortcut icon" href="https://star2dust.github.io/favicon.ico?v=1653562814638">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://star2dust.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="【力扣刷题】双指针和滑动窗口 | star2dust - Atom Feed" href="https://star2dust.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
双指针

27. 移除元素
26. 删除有序数组中的重复项
80. 删除有序数组中的重复项 II
844. 比较含退格的字符串
977.有序数组的平方


滑动窗口

209.长度最小的子数组
904.水果成篮
76.最小覆盖子串



..." />
    <meta name="keywords" content="Algorithm" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://star2dust.github.io">
  <img class="avatar" src="https://star2dust.github.io/images/avatar.png?v=1653562814638" alt="">
  </a>
  <h1 class="site-title">
    star2dust
  </h1>
  <p class="site-description">
    每天进步一点点
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://blog.csdn.net/u010038790" class="menu" target="_blank">
          博客
        </a>
      
    
      
        <a href="https://github.com/star2dust/paper-simulation" class="menu" target="_blank">
          论文复现
        </a>
      
    
      
        <a href="https://github.com/star2dust/Robotics-Toolbox" class="menu" target="_blank">
          工具箱
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/star2dust" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
        <a href="https://weibo.com/u/2473019655/" target="_blank">
          <i class="ri-weibo-line"></i>
        </a>
      
    
      
        <a href="https://www.zhihu.com/people/dong-nan-che" target="_blank">
          <i class="ri-zhihu-line"></i>
        </a>
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              【力扣刷题】双指针和滑动窗口
            </h2>
            <div class="post-info">
              <span>
                2021-11-28
              </span>
              <span>
                18 min read
              </span>
              
                <a href="https://star2dust.github.io/tag/DuA8BNEBr/" class="post-tag">
                  # Algorithm
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p><ul class="markdownIt-TOC">
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88">双指针</a>
<ul>
<li><a href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">27. 移除元素</a></li>
<li><a href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9">26. 删除有序数组中的重复项</a></li>
<li><a href="#80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii">80. 删除有序数组中的重复项 II</a></li>
<li><a href="#844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">844. 比较含退格的字符串</a></li>
<li><a href="#977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9">977.有序数组的平方</a></li>
</ul>
</li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a>
<ul>
<li><a href="#209%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">209.长度最小的子数组</a></li>
<li><a href="#904%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE">904.水果成篮</a></li>
<li><a href="#76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2">76.最小覆盖子串</a></li>
</ul>
</li>
</ul>
</p>
<p>本文总结了双指针和滑动窗口的常见题型。</p>
<h1 id="双指针">双指针</h1>
<p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</strong>，达到减少时间复杂度的作用。</p>
<p><strong>双指针法在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<h2 id="27-移除元素">27. 移除元素</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a>：给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
</code></pre>
</blockquote>
<p>数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</p>
<p>数组的基础知识可以看这里<a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">程序员算法面试中，必须掌握的数组理论知识</a>。</p>
<p>本题思路是，设置快慢指针，先同时移动，直到指向第一个要删除的位置，快指针多移动一位。</p>
<p>之后每次同时移动，做两件事：</p>
<ul>
<li>快指针位置的值复制到慢指针位置</li>
<li>快指针指向要删除位置时，快指针多移动一位</li>
</ul>
<p>最后慢指针位置即为数组长度。</p>
<pre><code class="language-cpp">// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="26-删除有序数组中的重复项">26. 删除有序数组中的重复项</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a>：给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
</code></pre>
</blockquote>
<p>注意到数组<strong>有序</strong>，因此重复元素必定相邻，那就简单多了。</p>
<pre><code class="language-cpp">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        // 判空
        if (nums.size()==0) return 0;
        // 如果非空，第一个数字不变，从第二个开始
        int l = 1;
        for (int r = 1; r &lt; nums.size(); r++){
            if (nums[r] != nums[l-1]){
                nums[l++] = nums[r];
            }
        }
        return l;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，只需要使用常数的额外空间。</p>
<h2 id="80-删除有序数组中的重复项-ii">80. 删除有序数组中的重复项 II</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a>：给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
</code></pre>
</blockquote>
<p>本题要求最多出现<code>2</code>次，直接的思路是加个计数项，如果重复个数超过2个就加一次拷贝动作。</p>
<pre><code class="language-cpp">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.size()==0) return 0;
        int l = 1, r = 1, cnt = 0;//计数
        while (r &lt; nums.size()){
            if (nums[r] != nums[r-1]){
                //加一次拷贝动作
                if (cnt &gt; 0) {
                    nums[l++] = nums[r-1];
                    cnt = 0;
                }
                nums[l++] = nums[r];
            }else{
                cnt++;
            }
            r++;
        }
        // 结尾还要加一次拷贝动作
        if (cnt &gt; 0) {
            nums[l++] = nums[r-1];
            cnt = 0;
        }
        return l;
    }
};
</code></pre>
<p>扩展一下，如果要求最多重复<code>k</code>次呢？</p>
<pre><code class="language-cpp">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums, int k) {
        if (nums.size() &lt;= k) return nums.size();
        int l = k, r = k;
        while (r &lt; nums.size()){
            if (nums[r] != nums[l-k]){
                nums[l++] = nums[r];
            }
            r++;
        }
        return l;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中 n 是数组的长度。我们最多遍历该数组一次。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，我们只需要常数的空间存储若干变量。</p>
<h2 id="844-比较含退格的字符串">844. 比较含退格的字符串</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/backspace-string-compare/">844. 比较含退格的字符串</a>：给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，请你判断二者是否相等。<code>#</code> 代表退格字符。</p>
<p>如果相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>**注意：**如果对空文本输入退格字符，文本继续为空。</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：s = &quot;ab#c&quot;, t = &quot;ad#c&quot;
输出：true
解释：S 和 T 都会变成 “ac”。
</code></pre>
</blockquote>
<p>本题中一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</p>
<p>具体地，我们定义<code>cnts</code>、<code>cntt</code>表示当前待删除的字符的数量。每次我们遍历到一个字符：</p>
<p>若该字符为退格符，则我们需要多删除一个普通字符，我们让<code>cnts</code>、<code>cntt</code>加 1；</p>
<p>若该字符为普通字符：</p>
<p>若<code>cnts</code>、<code>cntt</code>为 0，则说明当前字符不需要删去；</p>
<p>若<code>cnts</code>、<code>cntt</code>不为 0，则说明当前字符需要删去，我们让<code>cnts</code>、<code>cntt</code>减 1。</p>
<p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。</p>
<pre><code class="language-cpp">class Solution {
public:
    bool backspaceCompare(string s, string t) {
	int ps = s.length() - 1, pt = t.length() - 1;
	int cnts = 0, cntt = 0;
	while (ps &gt;= 0 || pt &gt;= 0){
        // s中查找下一个需要比较的字符
		while (ps &gt;= 0){
			if (s[ps] == '#'){
				cnts++; ps--;
			}
			else if (cnts &gt; 0){
				cnts--; ps--;
			}
			else{
				break;
			}
		}
        // t中查找下一个需要比较的字符
		while (pt &gt;= 0){
			if (t[pt] == '#'){
				cntt++; pt--;
			}
			else if (cntt &gt; 0){
				cntt--; pt--;
			}
			else{
				break;
			}
		}
        // ps、pt同时为0才可能相等
		if (ps &gt;= 0 &amp;&amp; pt &gt;= 0){
			if (s[ps] != t[pt]){
				return false;
			}
		}// 不同时为0直接结束比较
		else{
			if (ps &gt;= 0 || pt &gt;= 0){
				return false;
			}
		}
		ps--; pt--;
	}
	return true;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N+M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，其中 N 和 M 分别为字符串 S 和 T 的长度。我们需要遍历两字符串各一次。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。对于每个字符串，我们只需要定义一个指针和一个计数器即可。</p>
<h2 id="977有序数组的平方">977.有序数组的平方</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a>：给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
</code></pre>
</blockquote>
<p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>
<p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p>
<p>定义一个新数组result，和nums数组一样的大小，让k指向result数组终止位置。</p>
<p>如果<code>nums[i] * nums[i] &lt; nums[j] * nums[j]</code>  那么<code>result[k--] = nums[j] * nums[j];</code>  。</p>
<p>如果<code>nums[i] * nums[i] &gt;= nums[j] * nums[j]</code> 那么<code>result[k--] = nums[i] * nums[i];</code> 。</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int l = 0, r = n - 1, k = n - 1;
        vector&lt;int&gt; res(n);
        while (k&gt;=0){
            if (nums[l] * nums[l] &gt; nums[r] * nums[r]){
                res[k--] = nums[l] * nums[l];
                l++;
            }
            else{
                res[k--] = nums[r] * nums[r];
                r--;
            }
        }
        return res;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​，其中 n 是数组 nums 的长度，相对于暴力排序的解法<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n + n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​​还是提升不少的。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。除了存储答案的数组以外，我们只需要维护常量空间。</p>
<h1 id="滑动窗口">滑动窗口</h1>
<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>
<p>滑动窗口也可以理解为双指针法的一种，只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p>
<p>实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？（题目要求）</li>
<li>如何移动窗口的起始位置？（判断条件）</li>
<li>如何移动窗口的结束位置？（遍历指针）</li>
</ul>
<h2 id="209长度最小的子数组">209.长度最小的子数组</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209.长度最小的子数组</a>：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
</code></pre>
</blockquote>
<p>本题中的窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值<strong>大于s</strong>了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的<strong>结束位置就是遍历数组的指针</strong>，窗口的起始位置设置为数组的起始位置就可以了。</p>
<p>由于结束位置直接跟着循环跑，不用自己移动，所以滑动窗口也可以看作单指针。</p>
<p>可以发现<strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p>
<p>C++代码如下：</p>
<pre><code class="language-CPP">class Solution {
public:
    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j &lt; nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum &gt;= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result &lt; subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p><strong>为什么时间复杂度是O(n)</strong>。</p>
<p>不要以为for里放一个while就以为是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是2 * n 也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="904水果成篮">904.水果成篮</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮</a>：在一排树中，第 <code>i</code> 棵树产生 <code>tree[i]</code> 型的水果。</p>
<p>你可以<strong>从你选择的任何树开始</strong>，然后重复执行以下步骤：</p>
<ol>
<li>把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。</li>
<li>移动到当前树右侧的下一棵树。如果右边没有树，就停下来。</li>
</ol>
<p>请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</p>
<p>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。</p>
<p>用这个程序你能收集的水果树的最大总量是多少？</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：[0,1,2,2]
输出：3
解释：我们可以收集 [1,2,2]
如果我们从第一棵树开始，我们将只能收集到 [0, 1]。
</code></pre>
</blockquote>
<p>本题需要记录不同类型水果个数，使用哈希表当篮子。</p>
<p>本题中的窗口就是 两个装有不同类型水果的篮子。</p>
<p>窗口的起始位置如何移动：如果当前篮子数目<strong>大于2</strong>了，窗口就要向前移动了，同时依次减持水果，直到篮子数目重回2。</p>
<p>窗口的结束位置如何移动：窗口的<strong>结束位置就是遍历数组的指针</strong>，窗口的起始位置设置为数组的起始位置就可以了。</p>
<pre><code class="language-cpp">class Solution {
public:
    int totalFruit(vector&lt;int&gt;&amp; fruits) {
        unordered_map&lt;int, int&gt; basket;
        int result = 0, len = 0;
        int left = 0;
        for (int i = 0; i &lt; fruits.size(); i++) {
            basket[fruits[i]]++;
            len++;
            while (basket.size() &gt; 2) {
                basket[fruits[left]]--; //减掉left是因为采果子必须按顺序连续采
                if (basket[fruits[left]] == 0) basket.erase(fruits[left]); //直到某一个篮子为空
                left++;
                len--;
            }
            // 结束位置每移动一次，维护一次最大值
            result = max(result,len);
        }
        return result;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<h2 id="76最小覆盖子串">76.最小覆盖子串</h2>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>： 给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>示例 ：</strong></p>
<pre><code>输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;
输出：&quot;BANC&quot;
</code></pre>
</blockquote>
<p>本题由于<code>t</code>中存在重复字符，需要通过计数，确定字符是否找齐。</p>
<p>用<code>j</code>,<code>i</code>表示滑动窗口的左边界和右边界，当这个窗口包含的元素满足条件，即包含字符串<code>t</code>的所有元素，记录下这个滑动窗口的长度<code>i-j+1</code>，这些长度中的最小值就是要求的结果。</p>
<p><strong>步骤一</strong><br>
不断增加<code>i</code>使滑动窗口增大，直到窗口包含了<code>t</code>的所有元素（通过计数判断）</p>
<p><strong>步骤二</strong><br>
不断增加<code>j</code>使滑动窗口缩小，因为是要求最小字串，所以将不必要的元素排除在外，使长度减小，直到碰到一个必须包含的元素，记录此时滑动窗口的长度，并保存最小值</p>
<p><strong>步骤三</strong><br>
让<code>j</code>再增加一个位置，这个时候滑动窗口肯定不满足条件了，那么继续从步骤一开始执行，寻找新的满足条件的滑动窗口，如此反复，直到<code>i</code>超出了字符串<code>s</code>范围。</p>
<pre><code class="language-cpp">class Solution {
public:
    string minWindow(string s, string t) {
        int n = s.size(), m = t.size();
        vector&lt;int&gt; hash(128);
        for (char c : t) hash[c]--;
        string res = &quot;&quot;;
        for (int i = 0, j = 0, cnt = 0; i &lt; n; i++) {
            hash[s[i]]++;
            // 计数，t中的字符有几个被找到
            if (hash[s[i]] &lt;= 0) cnt++;
            // 找齐之后，要缩减一次长度，移动起始位置
            while (cnt == m &amp;&amp; hash[s[j]] &gt; 0) hash[s[j++]]--;
            // 缩减之后，比较并存最短长度
            if (cnt == m){
                if (res == &quot;&quot; || res.size() &gt; i - j + 1){
                    res = &quot;&quot;;
                    // 取[j,i]的子字符串
                    for (int k = j; k &lt;= i; k++){
                        res += s[k];
                    }
                }
            }   
        }
        return res;
    }
};
</code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88">双指针</a>
<ul>
<li><a href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">27. 移除元素</a></li>
<li><a href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9">26. 删除有序数组中的重复项</a></li>
<li><a href="#80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii">80. 删除有序数组中的重复项 II</a></li>
<li><a href="#844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">844. 比较含退格的字符串</a></li>
<li><a href="#977%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9">977.有序数组的平方</a></li>
</ul>
</li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a>
<ul>
<li><a href="#209%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">209.长度最小的子数组</a></li>
<li><a href="#904%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE">904.水果成篮</a></li>
<li><a href="#76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2">76.最小覆盖子串</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://star2dust.github.io/post/leetcode-acm-io/">
              <h3 class="post-title">
                【牛客刷题】输入输出练习
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '5f35b48460c7b593fee6',
    clientSecret: '19f3646e71158e91e93151d54f5d1a19b53ce961',
    repo: 'star2dust.github.io',
    owner: 'star2dust',
    admin: ['star2dust'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Copyright &copy;<span>star2dust</span>
  <a class="rss" href="https://star2dust.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
