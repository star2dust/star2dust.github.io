<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>飞桨强化学习从零实践（一）：基于价值的方法 | star2dust</title>

<link rel="shortcut icon" href="https://star2dust.github.io/favicon.ico?v=1598931668288">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://star2dust.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>

<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            star2dust
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="https://star2dust.github.io/ws-tetris/" class="menu gt-a-link" target="_blank">
                            俄罗斯方块
                        </a>
                    
                </div>
            
        </div>
    </div>
</nav>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    飞桨强化学习从零实践（一）：基于价值的方法
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-06-25 ·
                    </time>
                    
                        <a href="https://star2dust.github.io/tag/cXfWoOnM-/" class="post-tags">
                            # Reinforcement Learning
                        </a>
                    
                        <a href="https://star2dust.github.io/tag/R0pmglADx/" class="post-tags">
                            # Python
                        </a>
                    
                </div>
                <div class="post-content">
                    <p><ul class="markdownIt-TOC">
<li><a href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">写在前面</a></li>
<li><a href="#%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%8E%E5%B0%9D%E8%AF%95%E5%88%B0%E5%86%B3%E7%AD%96">强化学习——从尝试到决策</a>
<ul>
<li><a href="#%E5%88%9D%E8%AF%86%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0">初识强化学习</a></li>
<li><a href="#%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95">强化学习的分类和方法</a></li>
<li><a href="#parl%E6%A1%86%E6%9E%B6%E5%92%8Cgym%E7%8E%AF%E5%A2%83">PARL框架和GYM环境</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E8%A1%A8%E6%A0%BC%E5%9E%8B%E6%96%B9%E6%B3%95%E6%B1%82%E8%A7%A3rl">基于表格型方法求解RL</a>
<ul>
<li><a href="#%E5%BA%8F%E5%88%97%E5%86%B3%E7%AD%96%E7%9A%84%E7%BB%8F%E5%85%B8%E8%A1%A8%E8%BE%BEmdp">序列决策的经典表达（MDP）</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E5%8A%A8%E4%BD%9C%E4%BB%B7%E5%80%BCq%E7%9A%84%E6%B1%82%E8%A7%A3">状态动作价值（Q）的求解</a></li>
<li><a href="#sarsa%E5%92%8Cq-learning">Sarsa和Q-learning</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%BC%94%E7%A4%BA">代码构建与演示</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%96%B9%E6%B3%95%E6%B1%82%E8%A7%A3rl">基于神经网络方法求解RL</a>
<ul>
<li><a href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%BF%91%E4%BC%BCq%E5%87%BD%E6%95%B0">神经网络近似Q函数</a></li>
<li><a href="#dqn%E5%85%A5%E9%97%A8deep-rl">DQN：入门deep RL</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%BC%94%E7%A4%BA-2">代码构建与演示</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</p>
<h1 id="写在前面">写在前面</h1>
<blockquote>
<p>不要重复造轮子，学会使用轮子。</p>
</blockquote>
<p>本文源于百度AI平台飞桨学院《<a href="https://aistudio.baidu.com/aistudio/education/group/info/1335">世界冠军带你从零实践强化学习</a>》课程中我自己的心得和理解，感谢科科老师这几天精彩的讲解，带我们从小乌龟（Sarsa、Q-learning），到倒立摆（DQN，PG），再到四旋翼飞行器（DDPG），逐步领略强化学习的魅力。本文旨在介绍PARL框架的使用方法，并从模型的理解和代码的构建角度来整理所学内容，不求详尽但求简洁明了，看完都能学会<code>Model</code>、<code>Algorithm</code>、<code>Agent</code>的构建方法。我认为强化学习中对算法每一个概念的理解很重要，你可以不懂公式的推导，但是只要你理解了算法框图中的每一个步骤，那你就能够灵活的应用PARL框架去解决自己的问题。为了让大家理解代码的模块化构建，这篇文章只介绍Sarsa、Q-learning和DQN，前两者只用了一个<code>Agent</code>函数，后者用了PARL的<code>Model</code>、<code>Algorithm</code>、<code>Agent</code>模块，对比两种构建方式的不同，我们就可以很轻松的举一反三，PG和DDPG同样也可以用这三大模块构建。</p>
<p>依赖库是python初学者永远的痛点，相信很多人都有网上查到代码，本地一运行各种报错的经历，本文在各代码之前列举了所需依赖库，希望大家自己研究代码时能一次跑通。所有课程官方代码和作业答案都已上传至我的<a href="https://github.com/star2dust/parl-notes">GitHub</a>，欢迎大家star一下，文章中有问题或疏漏的地方大家也可以直接查看源码。</p>
<p>开始之前我希望大家都具有python编程基础，一定程度上掌握Numpy的用法，这个库真的是很有用。没用过的可以参考我之前的文章（<a href="https://star2dust.github.io/post/ndarray-notes/">查看这里</a>）。学习过程中也可以参考大神的文章，推荐<a href="https://www.zhihu.com/people/tiny-tony-5/posts">Tiny Tony</a>、<a href="https://blog.csdn.net/zbp_12138/article/details/106800911">Mr.郑先生_</a>、<a href="https://www.zhihu.com/people/hhhsy-9/posts">hhhsy</a>、<a href="https://www.zhihu.com/people/qqiang00/posts">叶强</a>。</p>
<h1 id="强化学习从尝试到决策">强化学习——从尝试到决策</h1>
<blockquote>
<p>每个人都是过去经验的总和。</p>
</blockquote>
<h2 id="初识强化学习">初识强化学习</h2>
<p>强化学习（Reinforcement learning，简称RL）是机器学习中的一个领域，强调如何基于环境而行动，以取得最大化的预期利益。核心思想是：智能体（agent）在环境（environment）中学习，根据环境的状态（state）或观测（observation），执行动作（action），并根据环境的反馈 （reward）来指导更好的动作。</p>
<figure data-type="image" tabindex="1"><img src="https://star2dust.github.io/post-images/1595416829986.png" alt="强化学习核心思想" loading="lazy"></figure>
<p>作为机器学习三巨头之一，强化学习和监督学习以及非监督学习关系如下图。</p>
<figure data-type="image" tabindex="2"><img src="https://star2dust.github.io/post-images/1595416878231.png" alt="机器学习三巨头" loading="lazy"></figure>
<p><strong>监督学习关注的是认知，而强化学习关注的是决策</strong>。简单的说，前者学习经验，后者运用经验。同样都是一张小熊的图片，监督学习输出的是灰熊、熊猫还是老虎，强化学习输出的是装死、逃跑还是干一架。</p>
<figure data-type="image" tabindex="3"><img src="https://star2dust.github.io/post-images/1595417013041.png" alt="熊来了怎么办？强化学习告诉你" loading="lazy"></figure>
<h2 id="强化学习的分类和方法">强化学习的分类和方法</h2>
<figure data-type="image" tabindex="4"><img src="https://star2dust.github.io/post-images/1595417062501.png" alt="强化学习的分类" loading="lazy"></figure>
<p>强化学习主要关注的是无模型的问题，在未知的环境中进行探索学习，在生活中有广泛的应用。</p>
<figure data-type="image" tabindex="5"><img src="https://star2dust.github.io/post-images/1595417136885.png" alt="强化学习应用" loading="lazy"></figure>
<p>其探索方案有二：</p>
<ul>
<li>基于价值的方法（Q函数）<br>
给每个状态都赋予一个价值的概念，来代表这个状态是好还是坏，这是一个相对的概念，让智能体往价值最高的方向行进。基于价值是确定性的。</li>
<li>基于策略的方法（Policy）<br>
制定出多个策略，策略里的每个动作都有一定的概率，并让每一条策略走到底,最后查看哪个策略是最优的。基于策略是随机性的。</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://star2dust.github.io/post-images/1595417207264.png" alt="强化学习方法" loading="lazy"></figure>
<h2 id="parl框架和gym环境">PARL框架和GYM环境</h2>
<ul>
<li>强化学习经典<strong>环境库GYM</strong>将环境（Env）交互接口规范化为：重置环境<code>reset()</code>、交互<code>step()</code>、渲染<code>render()</code>。</li>
<li>强化学习<strong>框架库PARL</strong>将强化学习框架抽象为: <code>Model</code>、<code>Algorithm</code>、<code>Agent</code>三层，使得强化学习算法的实现和调试更方便和灵活。（前两者有神经网络才用得上）</li>
</ul>
<p><code>Agent</code>的训练（Train）和测试（Test）过程直接上图展示如下。</p>
<figure data-type="image" tabindex="7"><img src="https://star2dust.github.io/post-images/1595417256567.png" alt="gym中agent训练和测试过程" loading="lazy"></figure>
<p>本文所需全部依赖库代码如下，paddlepaddle默认使用CPU版本，可自行选用GPU版本，这里不再赘述。</p>
<pre><code class="language-shell"># 可以直接 pip install -r requirements.txt
pip install paddlepaddle==1.6.3
pip install parl==1.3.1
pip install gym
pip install atari-py
pip install rlschool==0.3.1
</code></pre>
<h1 id="基于表格型方法求解rl">基于表格型方法求解RL</h1>
<blockquote>
<p>没有什么比前人走过的路（Q）更有价值（V）。</p>
</blockquote>
<h2 id="序列决策的经典表达mdp">序列决策的经典表达（MDP）</h2>
<p>某一状态信息包含了所有相关的历史，只要当前状态可知，所有的历史信息都不再需要，当前状态就可以决定未来，则认为该状态具有<strong>马尔科夫性</strong>。<strong>马尔可夫决策过程</strong>（MDP）是序列决策的数学模型，它是一个无记忆的随机过程，可以用一个元组&lt;S,P&gt;表示，其中S是有限数量的状态集，P是状态转移概率矩阵。</p>
<p>强化学习中我们引入奖励R和动作A来描述环境，构成MDP五元组&lt;S,A,P,R,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>&gt;，其中P函数表示环境的随机性，R函数其实是P函数的一部分，表示获得的收益，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>是衰减因子以适当的减少对未来收益的考虑。</p>
<figure data-type="image" tabindex="8"><img src="https://star2dust.github.io/post-images/1595417319990.png" alt="熊问题树形图" loading="lazy"></figure>
<p>同样以熊问题为例，对应的是Model-free的情况，即P函数和R函数都未知的情况。这时我们用价值V代表某一状态的好坏，用Q函数来代表某个状态下哪个动作更好，即状态动作价值。</p>
<figure data-type="image" tabindex="9"><img src="https://star2dust.github.io/post-images/1595417397753.png" alt="熊问题model-free" loading="lazy"></figure>
<p>现实世界中，奖励R往往是延迟的，所以一般会从当前时间点开始，对后续可能得到的收益累加，以此来计算当前的价值。但是有时候目光不要放得太长远，<strong>对远一些的东西当作近视看不见就好</strong>。适当地引入一个衰减因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>，再去计算未来的总收益，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>的值在0-1之间，时间点越久远，对当前的影响也就越小。</p>
<h2 id="状态动作价值q的求解">状态动作价值（Q）的求解</h2>
<p>假设人走在树林里，先看到树上有熊爪后看到熊，接着就看到熊发怒了，经过很多次之后，原来要见到熊才瑟瑟发抖的，后来只要见到树上有熊爪就会有晕眩和害怕的感觉。也就是说，在不断地训练之后，下一个状态的价值可以不断地强化、影响上一个状态的价值。</p>
<p>这样的迭代状态价值的强化方式被称为时序差分（Temporal Difference）。单步求解Q函数，用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mo>(</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">Q(S_{t+1},A_{t+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>来近似<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">G_{t+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，以迭代的方式简化数学公式，最终使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mo>(</mo><msub><mi>S</mi><mi>t</mi></msub><mo separator="true">,</mo><msub><mi>A</mi><mi>t</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">Q(S_t,A_t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>逼近目标值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">G_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。这里的目标值Target就是前面提到的未来收益的累加。</p>
<figure data-type="image" tabindex="10"><img src="https://star2dust.github.io/post-images/1595417455942.png" alt="Q表格TD单步更新" loading="lazy"></figure>
<h2 id="sarsa和q-learning">Sarsa和Q-learning</h2>
<p><strong>Sarsa</strong>全称是state-action-reward-state’-action’，目的是学习特定的state下，特定action的价值Q，最终建立和优化一个Q表格，以state为行，action为列，根据与环境交互得到的reward来更新Q表格，更新公式即为上面的迭代公式。Sarsa在训练中为了更好的探索环境，采用ε-greedy方式（如下图）来训练，有一定概率随机选择动作输出。</p>
<figure data-type="image" tabindex="11"><img src="https://star2dust.github.io/post-images/1595417521961.png" alt="e_greedy" loading="lazy"></figure>
<p><strong>Q-learning</strong>也是采用Q表格的方式存储Q值，探索部分与Sarsa是一样的，采用ε-greedy方式增加探索。</p>
<ul>
<li>Q-learning跟Sarsa不一样的地方是更新Q表格的方式，即learn()函数。</li>
<li>Sarsa是on-policy，先做出动作再learn，Q-learning是off-policy，learn时无需获取下一步动作。</li>
</ul>
<p>二者更新Q表格的方式分别为：</p>
<figure data-type="image" tabindex="12"><img src="https://star2dust.github.io/post-images/1595417538287.png" alt="sarsa和qlearning更新Q表格方式对比" loading="lazy"></figure>
<p>二者算法对比如下图所示，有三处不同点。</p>
<figure data-type="image" tabindex="13"><img src="https://star2dust.github.io/post-images/1595417548868.png" alt="sarsa和qlearning算法对比" loading="lazy"></figure>
<p>on-policy优化的是目标策略，用下一步一定会执行的动作来优化Q表格；off-policy实际上有两种不同的策略，期望得到的目标策略和大胆探索的行为策略，在目标策略的基础上用行为策略获得更多的经验。</p>
<figure data-type="image" tabindex="14"><img src="https://star2dust.github.io/post-images/1595417559359.png" alt="离线在线之争" loading="lazy"></figure>
<h2 id="代码构建与演示">代码构建与演示</h2>
<pre><code class="language-python">import numpy as np
</code></pre>
<p>Sarsa Agent构建</p>
<pre><code class="language-python">class SarsaAgent(object):
    def __init__(self,
                 obs_n,
                 act_n,
                 learning_rate=0.01,
                 gamma=0.9,
                 e_greed=0.1):
        self.act_n = act_n  # 动作维度，有几个动作可选
        self.lr = learning_rate  # 学习率
        self.gamma = gamma  # reward的衰减率
        self.epsilon = e_greed  # 按一定概率随机选动作
        self.Q = np.zeros((obs_n, act_n))

    # 根据输入观察值，采样输出的动作值，带探索
    def sample(self, obs):
        if np.random.uniform(0, 1) &lt; (1.0 - self.epsilon):  #根据table的Q值选动作
            action = self.predict(obs)
        else:
            action = np.random.choice(self.act_n)  #有一定概率随机探索选取一个动作
        return action

    # 根据输入观察值，预测输出的动作值
    def predict(self, obs):
        Q_list = self.Q[obs, :]
        maxQ = np.max(Q_list)
        action_list = np.where(Q_list == maxQ)[0]  # maxQ可能对应多个action
        action = np.random.choice(action_list)
        return action

    # 学习方法，也就是更新Q-table的方法
    def learn(self, obs, action, reward, next_obs, next_action, done):
        &quot;&quot;&quot; on-policy
            obs: 交互前的obs, s_t
            action: 本次交互选择的action, a_t
            reward: 本次动作获得的奖励r
            next_obs: 本次交互后的obs, s_t+1
            next_action: 根据当前Q表格, 针对next_obs会选择的动作, a_t+1
            done: episode是否结束
        &quot;&quot;&quot;
        predict_Q = self.Q[obs, action]
        if done:
            target_Q = reward  # 没有下一个状态了
        else:
            target_Q = reward + self.gamma * self.Q[next_obs,
                                                    next_action]  # Sarsa
        self.Q[obs, action] += self.lr * (target_Q - predict_Q)  # 修正q
</code></pre>
<p>Q-learning Agent构建</p>
<pre><code class="language-python">class QLearningAgent(object):
    def __init__(self,
                 obs_n,
                 act_n,
                 learning_rate=0.01,
                 gamma=0.9,
                 e_greed=0.1):
        self.act_n = act_n  # 动作维度，有几个动作可选
        self.lr = learning_rate  # 学习率
        self.gamma = gamma  # reward的衰减率
        self.epsilon = e_greed  # 按一定概率随机选动作
        self.Q = np.zeros((obs_n, act_n))

    # 根据输入观察值，采样输出的动作值，带探索
    def sample(self, obs):
        # 内容略，和sarsa一样
        return action

    # 根据输入观察值，预测输出的动作值
    def predict(self, obs):
        # 内容略，和sarsa一样
        return action

    # 学习方法，也就是更新Q-table的方法
    def learn(self, obs, action, reward, next_obs, done):
        &quot;&quot;&quot; off-policy
            obs: 交互前的obs, s_t
            action: 本次交互选择的action, a_t
            reward: 本次动作获得的奖励r
            next_obs: 本次交互后的obs, s_t+1
            done: episode是否结束
        &quot;&quot;&quot;
        predict_Q = self.Q[obs, action]
        if done:
            target_Q = reward  # 没有下一个状态了
        else:
            target_Q = reward + self.gamma * np.max(
                self.Q[next_obs, :])  # Q-learning
        self.Q[obs, action] += self.lr * (target_Q - predict_Q)  # 修正q
</code></pre>
<p>训练过程代码如下：</p>
<pre><code class="language-python"># train.py
import gym
from gridworld import CliffWalkingWapper, FrozenLakeWapper
from agent import SarsaAgent
import time


def run_episode(env, agent, render=False):
    total_steps = 0  # 记录每个episode走了多少step
    total_reward = 0

    obs = env.reset()  # 重置环境, 重新开一局（即开始新的一个episode）
    action = agent.sample(obs)  # 根据算法选择一个动作

    while True:
        next_obs, reward, done, _ = env.step(action)  # 与环境进行一个交互
        next_action = agent.sample(next_obs)  # 根据算法选择一个动作
        # 训练 Sarsa 算法
        agent.learn(obs, action, reward, next_obs, next_action, done)
        action = next_action # 存储上一个动作
        # 训练 q-learing 算法
        # agent.learn(obs, action, reward, next_obs, done)
        
        obs = next_obs  # 存储上一个观察值
        total_reward += reward
        total_steps += 1  # 计算step数
        if render:
            env.render()  #渲染新的一帧图形
        if done:
            break
    return total_reward, total_steps


def test_episode(env, agent):
    total_reward = 0
    obs = env.reset()
    while True:
        action = agent.predict(obs)  # greedy
        next_obs, reward, done, _ = env.step(action)
        total_reward += reward
        obs = next_obs
        time.sleep(0.5)
        env.render()
        if done:
            print('test reward = %.1f' % (total_reward))
            break


def main():
    # env = gym.make(&quot;FrozenLake-v0&quot;, is_slippery=False)  # 0 left, 1 down, 2 right, 3 up
    # env = FrozenLakeWapper(env)

    env = gym.make(&quot;CliffWalking-v0&quot;)  # 0 up, 1 right, 2 down, 3 left
    env = CliffWalkingWapper(env)

    agent = SarsaAgent(
        obs_n=env.observation_space.n,
        act_n=env.action_space.n,
        learning_rate=0.1,
        gamma=0.9,
        e_greed=0.1) # 或 QLearningAgent

    is_render = False
    for episode in range(500):
        ep_reward, ep_steps = run_episode(env, agent, is_render)
        print('Episode %s: steps = %s , reward = %.1f' % (episode, ep_steps,
                                                          ep_reward))

        # 每隔20个episode渲染一下看看效果
        if episode % 20 == 0:
            is_render = True
        else:
            is_render = False
    # 训练结束，查看算法效果
    test_episode(env, agent)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<p>可以看到二者区别全在<code>learn</code>函数，训练过程的差别也仅在<code>learn</code>的输入是否有<code>next_action</code>。大家可以尝试用命令行运行以下演示代码（<a href="https://github.com/star2dust/parl-notes">这里下载</a>），训练环境是悬崖问题（CliffWalking）。作业中的冰湖问题（FrozenLake）见<code>.\tutorials\homework</code>文件夹。</p>
<pre><code class="language-shell"># sarsa 演示
cd .\tutorials\lesson2\sarsa
python .\train.py
# q-learing 演示
cd .\tutorials\lesson2\q_learning
python .\train.py
</code></pre>
<p>最终结果如下面的GIF所示。可以看出来Sarsa比较保守，会选择下限最高的路线，即尽可能远离悬崖的路线，虽然路程远了，但至少掉下悬崖的风险就小了很多；而Q-learning比较激进，会选择上限最高的路线，即路程最近的路线，但存在些微扰动便可能掉下悬崖。</p>
<p>Sarsa训练图：</p>
<figure data-type="image" tabindex="15"><img src="https://star2dust.github.io/post-images/1595417809738.gif" alt="Sarsa训练图" loading="lazy"></figure>
<p>Q-learning训练图：</p>
<figure data-type="image" tabindex="16"><img src="https://star2dust.github.io/post-images/1595417820699.gif" alt="QLearning训练图" loading="lazy"></figure>
<h1 id="基于神经网络方法求解rl">基于神经网络方法求解RL</h1>
<blockquote>
<p>选择（A）有限，而人生（S）无限。</p>
</blockquote>
<h2 id="神经网络近似q函数">神经网络近似Q函数</h2>
<p>前面提到的悬崖问题，状态（S）总量很少，但实际生活中，很多常见问题的状态都是数量庞大的，如象棋、围棋等。即使用Q表格装下所有状态，表格可能占用极大内存，表格的查找也相当费时。我们就可以用带参数的Q函数来近似Q表格，比如可以用多项式函数或者神经网络，优势是<strong>只需要输出少量参数，同时能实现状态泛化</strong>。</p>
<p>神经网络结构如下图所示。</p>
<figure data-type="image" tabindex="17"><img src="https://star2dust.github.io/post-images/1595417909622.png" alt="神经网络结构" loading="lazy"></figure>
<ul>
<li><strong>神经元</strong>：神经网络中每个节点称为神经元，由两部分组成：
<ul>
<li>加权和：将所有输入加权求和。</li>
<li>非线性变换（<strong>激活函数</strong>）：加权和的结果经过一个非线性函数变换，让神经元计算具备<strong>非线性</strong>的能力。</li>
</ul>
</li>
<li><strong>多层连接：</strong> 大量这样的节点按照不同的层次排布，形成多层的结构连接起来，即称为神经网络。</li>
<li><strong>前向计算：</strong> 从输入计算输出的过程，顺序从网络前至后。</li>
<li><strong>计算图：</strong> 以图形化的方式展现神经网络的计算逻辑又称为计算图。我们也可以将神经网络的计算图以公式的方式表达为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>=</mo><msub><mi>f</mi><mn>3</mn></msub><mo>(</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>w</mi><mn>3</mn></msub><msub><mi>x</mi><mn>3</mn></msub><mo>+</mo><mi>b</mi><mo>)</mo><mo>+</mo><mo>⋯</mo><mtext> </mtext><mo>)</mo><mo>+</mo><mo>⋯</mo><mtext> </mtext><mo>)</mo></mrow><annotation encoding="application/x-tex">Y=f_3(f_2(f_1(w_1x_1+w_2x_2+w_3x_3+b)+\cdots)+\cdots)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>由此可见，神经网络的本质是一个含有很多参数的“大公式”。</p>
<h2 id="dqn入门deep-rl">DQN：入门deep RL</h2>
<p>DQN本质上是一个Q-learning算法，但使用神经网络来近似替代Q表格。</p>
<figure data-type="image" tabindex="18"><img src="https://star2dust.github.io/post-images/1595418122575.png" alt="DQN流程" loading="lazy"></figure>
<p>类比监督学习的训练，DQN的训练过程也非常地类似，它输入的是一批状态（S），输出的是对应的Q。计算输出的Q与Target Q的均方差，进行优化，以此更新神经网络参数。</p>
<figure data-type="image" tabindex="19"><img src="https://star2dust.github.io/post-images/1595418135390.png" alt="DQN类比监督学习" loading="lazy"></figure>
<p>在Q-learning的基础上，DQN提出了两个技巧使得Q网络的更新迭代更稳定:</p>
<ul>
<li><strong>经验回放</strong> （Experience Replay）：主要解决样本关联性和利用效率的问题。使用一个经验池（buffer）存储多条经验（s,a,r,s’），再从中随机抽取一批（batch）数据送去训练。</li>
<li><strong>固定Q目标</strong> （Fixed-Q-Target）：主要解决算法训练不稳定的问题。每隔一段时间复制一次网络参数（w），保证用于计算Target Q的Q函数不变。</li>
</ul>
<h2 id="代码构建与演示-2">代码构建与演示</h2>
<p>这部分代码构建展示了PARL框架的基本用法，即<code>Model</code>、<code>Algorithm</code>、<code>Agent</code>嵌套。<code>Algorithm</code>是<code>Agent</code>的一部分，<code>Model</code>又是<code>Algorithm</code>的一部分，相比较前文中只有一个<code>Agent</code>的简单代码模块性更好，但理解起来也更复杂，容我慢慢道来。</p>
<pre><code class="language-python">import parl
from parl import layers
import paddle.fluid as fluid
import copy
import numpy as np
</code></pre>
<ul>
<li><code>Model</code>用来定义前向(<code>Forward</code>)网络，用户可以自由的定制自己的神经网络结构。</li>
</ul>
<pre><code class="language-python">class Model(parl.Model):
    def __init__(self, act_dim):
        hid1_size = 128
        hid2_size = 128
        # 3层全连接（fc）网络，act选择激活函数，不使用激活函数即线性
        self.fc1 = layers.fc(size=hid1_size, act='relu')
        self.fc2 = layers.fc(size=hid2_size, act='relu')
        self.fc3 = layers.fc(size=act_dim, act=None)

    def value(self, obs):
        # 前向计算 Q实际上是一个二维数组
        # 输入state，输出所有action对应的Q，[Q(s,a1), Q(s,a2), Q(s,a3)...]
        h1 = self.fc1(obs)
        h2 = self.fc2(h1)
        Q = self.fc3(h2)
        return Q
</code></pre>
<ul>
<li><code>Algorithm</code> 定义了具体的算法来更新前向网络(<code>Model</code>)，也就是通过定义损失函数来更新<code>Model</code>，和算法相关的计算都放在<code>algorithm</code>中。</li>
</ul>
<pre><code class="language-python"># from parl.algorithms import DQN # 也可以直接从parl库中导入DQN算法

class DQN(parl.Algorithm):
    def __init__(self, model, act_dim=None, gamma=None, lr=None):
        &quot;&quot;&quot; DQN algorithm
        
        Args:
            model (parl.Model): 定义Q函数的前向网络结构
            act_dim (int): action空间的维度，即有几个action
            gamma (float): reward的衰减因子
            lr (float): learning rate 学习率.
        &quot;&quot;&quot;
        self.model = model
        self.target_model = copy.deepcopy(model)
        # 参数的类型要求，且必须有输入
        assert isinstance(act_dim, int)
        assert isinstance(gamma, float)
        assert isinstance(lr, float)
        self.act_dim = act_dim
        self.gamma = gamma
        self.lr = lr

    def predict(self, obs):
        &quot;&quot;&quot; 使用self.model的value网络来获取 [Q(s,a1),Q(s,a2),...]
        &quot;&quot;&quot;
        return self.model.value(obs)

    def learn(self, obs, action, reward, next_obs, terminal):
        &quot;&quot;&quot; 使用DQN算法更新self.model的value网络
        &quot;&quot;&quot;
        # 从target_model中获取 max Q' 的值，用于计算target_Q
        next_pred_value = self.target_model.value(next_obs)        
        # dim=0指最外边的[]，dim增加向内数一个[]
        # 这里value都自带两个[]，所以dim=1，计算里面那个[]
        best_v = layers.reduce_max(next_pred_value, dim=1)
        # 阻止梯度传递保证target不变，否则paddle的优化器默认迭代一步梯度
        best_v.stop_gradient = True  
        # 判断是否是最后一条经验
        terminal = layers.cast(terminal, dtype='float32')
        target = reward + (1.0 - terminal) * self.gamma * best_v

        pred_value = self.model.value(obs)  # 获取Q预测值
        # 将action转onehot向量，比如：3 =&gt; [0,0,0,1,0]
        action_onehot = layers.one_hot(action, self.act_dim)
        action_onehot = layers.cast(action_onehot, dtype='float32')
        # 下面一行是逐元素相乘，拿到action对应的 Q(s,a)
        # 比如：pred_value = [[2.3, 5.7, 1.2, 3.9, 1.4]], action_onehot = [[0,0,0,1,0]]
        #  ==&gt; pred_action_value = [[3.9]]
        pred_action_value = layers.reduce_sum(
            layers.elementwise_mul(action_onehot, pred_value), dim=1)

        # 计算 Q(s,a) 与 target_Q的均方差，得到loss
        cost = layers.square_error_cost(pred_action_value, target)
        cost = layers.reduce_mean(cost)
        optimizer = fluid.optimizer.Adam(learning_rate=self.lr)  # 使用Adam优化器
        optimizer.minimize(cost)
        return cost

    def sync_target(self):
        &quot;&quot;&quot; 把 self.model 的模型参数值同步到 self.target_model
        &quot;&quot;&quot;
        # 同步参数就行，比直接copy效率高
        self.model.sync_weights_to(self.target_model)
</code></pre>
<ul>
<li><code>Agent</code> 负责算法与环境的交互，在交互过程中把生成的数据提供给<code>Algorithm</code>来更新模型(<code>Model</code>)，数据的预处理流程也一般定义在这里。</li>
</ul>
<pre><code class="language-python">class Agent(parl.Agent):
    def __init__(self,
                 algorithm,
                 obs_dim,
                 act_dim,
                 e_greed=0.1,
                 e_greed_decrement=0):
        assert isinstance(obs_dim, int)
        assert isinstance(act_dim, int)
        self.obs_dim = obs_dim
        self.act_dim = act_dim
        # 将Algorithm传入Agent，即self.alg
        super(Agent, self).__init__(algorithm)

        self.global_step = 0
        self.update_target_steps = 200  
        # 每隔200个training steps再把model的参数复制到target_model中

        self.e_greed = e_greed  # 有一定概率随机选取动作，探索
        self.e_greed_decrement = e_greed_decrement  # 随着训练逐步收敛，探索的程度慢慢降低

    def build_program(self):
        # 这一部分是搭建predict和learn框架，给定数据大小和类型
        # 至于输入实际数据的代码，在后面的predict和learn函数
        self.pred_program = fluid.Program()
        self.learn_program = fluid.Program()

        with fluid.program_guard(self.pred_program):  
            # 搭建计算图用于 预测动作，定义输入输出变量
            obs = layers.data(
                name='obs', shape=[self.obs_dim], dtype='float32')
            self.value = self.alg.predict(obs)

        with fluid.program_guard(self.learn_program):  
            # 搭建计算图用于 更新Q网络，定义输入输出变量
            obs = layers.data(
                name='obs', shape=[self.obs_dim], dtype='float32')
            action = layers.data(name='act', shape=[1], dtype='int32')
            reward = layers.data(name='reward', shape=[], dtype='float32')
            next_obs = layers.data(
                name='next_obs', shape=[self.obs_dim], dtype='float32')
            terminal = layers.data(name='terminal', shape=[], dtype='bool')
            self.cost = self.alg.learn(obs, action, reward, next_obs, terminal)

    def sample(self, obs):
        sample = np.random.rand()  # 产生0~1之间的小数
        if sample &lt; self.e_greed:
            act = np.random.randint(self.act_dim)  # 探索：每个动作都有概率被选择
        else:
            act = self.predict(obs)  # 选择最优动作
        # 前面和sarsa基本一样，不同的是随着训练逐步收敛，探索的程度慢慢降低
        self.e_greed = max(
            0.01, self.e_greed - self.e_greed_decrement)     
        return act

    def predict(self, obs):  # 选择最优动作，和sample的else部分一致
        # 扩展维度，因为obs是[...]，但是Q是[[...]]
        obs = np.expand_dims(obs, axis=0)
        pred_Q = self.fluid_executor.run(
            self.pred_program,
            feed={'obs': obs.astype('float32')},
            fetch_list=[self.value])[0]
        # 降低维度，理由同上
        pred_Q = np.squeeze(pred_Q, axis=0) # 若axis=0的维度len==1则移除
        act = np.argmax(pred_Q)  # 选择Q最大的下标，即对应的动作
        return act

    def learn(self, obs, act, reward, next_obs, terminal):
        # 每隔200个training steps同步一次model和target_model的参数
        if self.global_step % self.update_target_steps == 0:
            self.alg.sync_target()
        self.global_step += 1

        act = np.expand_dims(act, -1)
        feed = {
            'obs': obs.astype('float32'),
            'act': act.astype('int32'),
            'reward': reward,
            'next_obs': next_obs.astype('float32'),
            'terminal': terminal
        }
        cost = self.fluid_executor.run(
            self.learn_program, feed=feed, fetch_list=[self.cost])[0]  # 训练一次网络
        return cost
</code></pre>
<ul>
<li>经验池<code>replay_memory</code>：用于存储多条经验，实现经验回放。</li>
</ul>
<pre><code class="language-python"># replay_memory.py
import random
import collections
import numpy as np


class ReplayMemory(object):
    def __init__(self, max_size):
        self.buffer = collections.deque(maxlen=max_size)

    # 增加一条经验到经验池中
    def append(self, exp):
        self.buffer.append(exp)

    # 从经验池中选取N条经验出来
    def sample(self, batch_size):
        mini_batch = random.sample(self.buffer, batch_size)
        obs_batch, action_batch, reward_batch, next_obs_batch, done_batch = [], [], [], [], []

        for experience in mini_batch:
            s, a, r, s_p, done = experience
            obs_batch.append(s)
            action_batch.append(a)
            reward_batch.append(r)
            next_obs_batch.append(s_p)
            done_batch.append(done)

        return np.array(obs_batch).astype('float32'), \
            np.array(action_batch).astype('float32'), 				np.array(reward_batch).astype('float32'),\
            np.array(next_obs_batch).astype('float32'), np.array(done_batch).astype('float32')

    def __len__(self):
        return len(self.buffer)
</code></pre>
<p>训练过程代码如下：</p>
<pre><code class="language-python"># train.py
import os
import gym
import numpy as np
import parl
from parl.utils import logger  # 日志打印工具

from model import Model
from algorithm import DQN  # from parl.algorithms import DQN  # parl &gt;= 1.3.1
from agent import Agent

from replay_memory import ReplayMemory

LEARN_FREQ = 5  # 训练频率，不需要每一个step都learn，攒一些新增经验后再learn，提高效率
MEMORY_SIZE = 20000  # replay memory的大小，越大越占用内存
MEMORY_WARMUP_SIZE = 200  # replay_memory 里需要预存一些经验数据，再从里面sample一个batch的经验让agent去learn
BATCH_SIZE = 32  # 每次给agent learn的数据数量，从replay memory随机里sample一批数据出来
LEARNING_RATE = 0.001  # 学习率
GAMMA = 0.99  # reward 的衰减因子，一般取 0.9 到 0.999 不等


# 训练一个episode
def run_episode(env, agent, rpm):
    total_reward = 0
    obs = env.reset()
    step = 0
    while True:
        step += 1
        action = agent.sample(obs)  # 采样动作，所有动作都有概率被尝试到
        next_obs, reward, done, _ = env.step(action)
        rpm.append((obs, action, reward, next_obs, done))

        # train model 每次learn都随机抽样
        if (len(rpm) &gt; MEMORY_WARMUP_SIZE) and (step % LEARN_FREQ == 0):
            (batch_obs, batch_action, batch_reward, batch_next_obs,
             batch_done) = rpm.sample(BATCH_SIZE)
            train_loss = agent.learn(batch_obs, batch_action, batch_reward,
                                     batch_next_obs,
                                     batch_done)  # s,a,r,s',done

        total_reward += reward
        obs = next_obs
        if done:
            break
    return total_reward


# 评估 agent, 跑 5 个episode，总reward求平均
def evaluate(env, agent, render=False):
    eval_reward = []
    for i in range(5):
        obs = env.reset()
        episode_reward = 0
        while True:
            action = agent.predict(obs)  # 预测动作，只选最优动作
            obs, reward, done, _ = env.step(action)
            episode_reward += reward
            if render:
                env.render()
            if done:
                break
        eval_reward.append(episode_reward)
    return np.mean(eval_reward)


def main():
    env = gym.make(
        'CartPole-v0'
    )  # CartPole-v0: expected reward &gt; 180                MountainCar-v0 : expected reward &gt; -120
    action_dim = env.action_space.n  # CartPole-v0: 2
    obs_shape = env.observation_space.shape  # CartPole-v0: (4,)

    rpm = ReplayMemory(MEMORY_SIZE)  # DQN的经验回放池

    # 根据parl框架构建agent
    model = Model(act_dim=action_dim)
    algorithm = DQN(model, act_dim=action_dim, gamma=GAMMA, lr=LEARNING_RATE)
    agent = Agent(
        algorithm,
        obs_dim=obs_shape[0],
        act_dim=action_dim,
        e_greed=0.1,  # 有一定概率随机选取动作，探索
        e_greed_decrement=1e-6)  # 随着训练逐步收敛，探索的程度慢慢降低

    # 加载模型
    # save_path = './dqn_model.ckpt'
    # agent.restore(save_path)

    # 先往经验池里存一些数据，避免最开始训练的时候样本丰富度不够
    while len(rpm) &lt; MEMORY_WARMUP_SIZE:
        run_episode(env, agent, rpm)

    max_episode = 2000

    # start train
    episode = 0
    while episode &lt; max_episode:  # 训练max_episode个回合，test部分不计算入episode数量
        # train part
        for i in range(0, 50):
            total_reward = run_episode(env, agent, rpm)
            episode += 1

        # test part
        eval_reward = evaluate(env, agent, render=True)  # render=True 查看显示效果
        logger.info('episode:{}    e_greed:{}   Test reward:{}'.format(
            episode, agent.e_greed, eval_reward))

    # 训练结束，保存模型
    save_path = './dqn_model.ckpt'
    agent.save(save_path)


if __name__ == '__main__':
    main()
</code></pre>
<p>大家可以尝试用命令行运行以下演示代码（<a href="https://github.com/star2dust/parl-notes">这里下载</a>），训练环境是倒立摆问题（CartPole），倒立摆可以说是强化学习中的hello world，入门必备。作业中的小车上山问题（MountainCar）见<code>.\tutorials\homework</code>文件夹。</p>
<pre><code class="language-python"># DQN 演示
cd .\tutorials\lesson3\dqn
python .\train.py
cd .\tutorials\homework\lesson3\dqn_mountaincar
python .\train.py
</code></pre>
<p>最终DQN结果如下面的GIF所示。</p>
<p>倒立摆（CartPole）：</p>
<figure data-type="image" tabindex="20"><img src="https://star2dust.github.io/post-images/1595418264689.gif" alt="cartpole训练图" loading="lazy"></figure>
<p>小车上山（MountainCar）：</p>
<figure data-type="image" tabindex="21"><img src="https://star2dust.github.io/post-images/1595418274795.gif" alt="mountaincar训练图" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<p>框架库PARL将强化学习框架抽象为: <code>Model</code>、<code>Algorithm</code>、<code>Agent</code>三层，使得强化学习算法的实现和调试更方便和灵活。前两者尤其针对deep RL的情况，有神经网络时直接调用paddle的api可以很方便的进行网络和算法的构建。本文由强化学习经典算法Sarsa和Q-learning扩展到deep RL的DQN算法，并以DQN为例讲解了PARL的使用方法。下篇文章我会讲基于policy的PG算法和用于连续状态控制的DDPG，敬请期待。</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://star2dust.github.io/post/ndarray-notes/" class="post-title gt-a-link">
                    ndarray数组基本结构和操作
                </a>
            </div>
        

        

        
            
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
<script>
    // md5.min.js
    !function(n){
        "use strict";
        function d(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}
        function f(n,t,r,e,o,u){return d((c=d(d(t,n),d(e,u)))<<(f=o)|c>>>32-f,r);var c,f}
        function l(n,t,r,e,o,u,c){return f(t&r|~t&e,n,t,o,u,c)}
        function v(n,t,r,e,o,u,c){return f(t&e|r&~e,n,t,o,u,c)}
        function g(n,t,r,e,o,u,c){return f(t^r^e,n,t,o,u,c)}
        function m(n,t,r,e,o,u,c){return f(r^(t|~e),n,t,o,u,c)}
        function i(n,t){var r,e,o,u,c;n[t>>5]|=128<<t%32,n[14+(t+64>>>9<<4)]=t;var f=1732584193,i=-271733879,a=-1732584194,h=271733878;for(r=0;r<n.length;r+=16)f=l(e=f,o=i,u=a,c=h,n[r],7,-680876936),h=l(h,f,i,a,n[r+1],12,-389564586),a=l(a,h,f,i,n[r+2],17,606105819),i=l(i,a,h,f,n[r+3],22,-1044525330),f=l(f,i,a,h,n[r+4],7,-176418897),h=l(h,f,i,a,n[r+5],12,1200080426),a=l(a,h,f,i,n[r+6],17,-1473231341),i=l(i,a,h,f,n[r+7],22,-45705983),f=l(f,i,a,h,n[r+8],7,1770035416),h=l(h,f,i,a,n[r+9],12,-1958414417),a=l(a,h,f,i,n[r+10],17,-42063),i=l(i,a,h,f,n[r+11],22,-1990404162),f=l(f,i,a,h,n[r+12],7,1804603682),h=l(h,f,i,a,n[r+13],12,-40341101),a=l(a,h,f,i,n[r+14],17,-1502002290),f=v(f,i=l(i,a,h,f,n[r+15],22,1236535329),a,h,n[r+1],5,-165796510),h=v(h,f,i,a,n[r+6],9,-1069501632),a=v(a,h,f,i,n[r+11],14,643717713),i=v(i,a,h,f,n[r],20,-373897302),f=v(f,i,a,h,n[r+5],5,-701558691),h=v(h,f,i,a,n[r+10],9,38016083),a=v(a,h,f,i,n[r+15],14,-660478335),i=v(i,a,h,f,n[r+4],20,-405537848),f=v(f,i,a,h,n[r+9],5,568446438),h=v(h,f,i,a,n[r+14],9,-1019803690),a=v(a,h,f,i,n[r+3],14,-187363961),i=v(i,a,h,f,n[r+8],20,1163531501),f=v(f,i,a,h,n[r+13],5,-1444681467),h=v(h,f,i,a,n[r+2],9,-51403784),a=v(a,h,f,i,n[r+7],14,1735328473),f=g(f,i=v(i,a,h,f,n[r+12],20,-1926607734),a,h,n[r+5],4,-378558),h=g(h,f,i,a,n[r+8],11,-2022574463),a=g(a,h,f,i,n[r+11],16,1839030562),i=g(i,a,h,f,n[r+14],23,-35309556),f=g(f,i,a,h,n[r+1],4,-1530992060),h=g(h,f,i,a,n[r+4],11,1272893353),a=g(a,h,f,i,n[r+7],16,-155497632),i=g(i,a,h,f,n[r+10],23,-1094730640),f=g(f,i,a,h,n[r+13],4,681279174),h=g(h,f,i,a,n[r],11,-358537222),a=g(a,h,f,i,n[r+3],16,-722521979),i=g(i,a,h,f,n[r+6],23,76029189),f=g(f,i,a,h,n[r+9],4,-640364487),h=g(h,f,i,a,n[r+12],11,-421815835),a=g(a,h,f,i,n[r+15],16,530742520),f=m(f,i=g(i,a,h,f,n[r+2],23,-995338651),a,h,n[r],6,-198630844),h=m(h,f,i,a,n[r+7],10,1126891415),a=m(a,h,f,i,n[r+14],15,-1416354905),i=m(i,a,h,f,n[r+5],21,-57434055),f=m(f,i,a,h,n[r+12],6,1700485571),h=m(h,f,i,a,n[r+3],10,-1894986606),a=m(a,h,f,i,n[r+10],15,-1051523),i=m(i,a,h,f,n[r+1],21,-2054922799),f=m(f,i,a,h,n[r+8],6,1873313359),h=m(h,f,i,a,n[r+15],10,-30611744),a=m(a,h,f,i,n[r+6],15,-1560198380),i=m(i,a,h,f,n[r+13],21,1309151649),f=m(f,i,a,h,n[r+4],6,-145523070),h=m(h,f,i,a,n[r+11],10,-1120210379),a=m(a,h,f,i,n[r+2],15,718787259),i=m(i,a,h,f,n[r+9],21,-343485551),f=d(f,e),i=d(i,o),a=d(a,u),h=d(h,c);return[f,i,a,h]}
        function a(n){var t,r="",e=32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t>>5]>>>t%32&255);return r}
        function h(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t<e;t+=8)r[t>>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}
        function e(n){var t,r,e="0123456789abcdef",o="";for(r=0;r<n.length;r+=1)t=n.charCodeAt(r),o+=e.charAt(t>>>4&15)+e.charAt(15&t);return o}
        function r(n){return unescape(encodeURIComponent(n))}
        function o(n){return a(i(h(t=r(n)),8*t.length));var t}
        function u(n,t){return function(n,t){var r,e,o=h(n),u=[],c=[];for(u[15]=c[15]=void 0,16<o.length&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(h(t)),512+8*t.length),a(i(c.concat(e),640))}(r(n),r(t))}
        function t(n,t,r){return t?r?u(t,n):e(u(t,n)):r?o(n):e(o(n))}
        "function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:n.md5=t;
    }(this);
</script>


<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '5f35b48460c7b593fee6',
    clientSecret: '19f3646e71158e91e93151d54f5d1a19b53ce961',
    repo: 'star2dust.github.io',
    owner: 'star2dust',
    admin: ['star2dust'],
    id: md5(location.pathname),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false       // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

            

            
        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">每天进步一点点</div>
    <div class="social-container">
        
            
                <a href="https://github.com/star2dust" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
                <a href="https://weibo.com/u/2473019655" target="_blank">
                    <i class="fab fa-weibo gt-c-content-color-first"></i>
                </a>
            
        
            
                <a href="https://www.zhihu.com/people/dong-nan-che" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Copyright &copy;<span>star2dust</span>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://star2dust.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
    hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
